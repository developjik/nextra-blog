---
title: 'Event Storming 완벽 가이드'
date: '2025-12-31'
description: 'Event Storming의 핵심 개념과 실제 워크숍 진행 방법을 알아봅니다. OMS/WMS 실무 예제를 통해 팀 전체가 비즈니스 프로세스를 이해하고 시스템 설계의 출발점을 만드는 방법을 배웁니다.'
tags: ['DDD', 'Event Storming', '설계', '워크숍', '마이크로서비스']
---

import { JsonLd } from '~/app/_components'

<JsonLd
  metadata={{
    title: 'Event Storming 완벽 가이드',
    description: 'Event Storming의 핵심 개념과 실제 워크숍 진행 방법을 알아봅니다. OMS/WMS 실무 예제를 통해 팀 전체가 비즈니스 프로세스를 이해하고 시스템 설계의 출발점을 만드는 방법을 배웁니다.',
    date: '2025-12-31',
    slug: 'event-storming-complete-guide',
    tags: ['DDD', 'Event Storming', '설계', '워크숍', '마이크로서비스'],
  }}
/>

# Event Storming 완벽 가이드

## 개요

Event Storming은 **이벤트 중심으로 비즈니스 프로세스를 시각화하는 협업 워크숍 기법**입니다. Alberto Brandolini가 2013년에 개발했으며, 도메인 주도 설계(DDD)의 핵심 도구로 사용됩니다. 몇 시간 안에 팀 전체가 도메인을 이해하고, 시스템 설계의 출발점을 만들 수 있습니다.

## 배경

### 왜 필요한가?

전통적인 시스템 설계에서는 다음과 같은 문제가 발생합니다:

1. **소통의 단절**: 도메인 전문가와 개발자가 서로 다른 언어로 대화
2. **숨은 복잡성**: 비즈니스 규칙과 예외 상황이 뒤늦게 발견됨
3. **부분적 이해**: 각자 맡은 부분만 알고 전체 흐름을 모름
4. **문서화 지연**: 시스템이 완성된 후에야 문서 작성

### Event Storming의 장점

- ✅ **빠른 지식 공유**: 몇 시간 만에 팀 전체가 도메인 이해
- ✅ **숨은 요구사항 발견**: 워크숍 중에 놓친 시나리오 발견
- ✅ **공통 언어 형성**: 유비쿼터스 언어(Ubiquitous Language) 정립
- ✅ **시스템 경계 파악**: 마이크로서비스나 바운디드 컨텍스트 식별

## 핵심 개념

### 스티커 색상과 의미

Event Storming은 **색상별 스티커**로 비즈니스 요소를 구분합니다:

| 색상 | 요소 | 의미 | 예시 |
|------|------|------|------|
| 🟧 주황색 | 도메인 이벤트 | 과거에 발생한 비즈니스 사실 | "주문이 생성됨", "결제가 완료됨" |
| 🟦 파란색 | 커맨드 | 이벤트를 발생시키는 명령/행동 | "주문 생성", "결제 요청" |
| 🟨 노란색 | 액터 | 커맨드를 실행하는 사람/시스템 | "고객", "관리자", "결제 시스템" |
| 🟪 보라색 | 정책/규칙 | 자동으로 실행되는 비즈니스 룰 | "재고 10개 미만이면 자동 발주" |
| 🟩 초록색 | 읽기 모델 | 의사결정에 필요한 정보 | "재고 현황", "고객 신용도" |
| 🟥 빨간색 | 핫스팟 | 논의가 필요한 문제/이슈 | "동시 주문 시 재고 처리?" |
| 🟫 핑크색 | 외부 시스템 | 외부 서비스 연동 | "PG사", "배송 추적 API" |

### 도메인 이벤트 작성 규칙

도메인 이벤트는 다음 규칙을 따릅니다:

```markdown
✅ 좋은 예시:
- "주문이 생성됨"
- "재고가 차감됨"
- "배송이 시작됨"

❌ 나쁜 예시:
- "주문 생성" (현재형 X)
- "주문을 생성한다" (미래형 X)
- "주문 데이터 저장" (기술적 표현 X)
```

**핵심**: 비즈니스 관점에서 **과거 시제**로 작성하세요.

## 워크숍 진행 방법

### 사전 준비

**물리적 준비물** (오프라인):
- 긴 벽면 또는 화이트보드 (최소 3m 이상)
- 색상별 포스트잇 (주황, 파랑, 노랑, 보라, 초록, 빨강)
- 펜 (검은색, 굵은 펜 권장)
- 마스킹 테이프

**온라인 도구** (리모트):
- Miro, Mural, FigJam 등 협업 화이트보드
- 템플릿 설정 (색상별 스티커 미리 준비)

**참가자**:
- 도메인 전문가 (비즈니스 담당자, PM)
- 개발자 (프론트엔드, 백엔드)
- 디자이너 (선택)
- 퍼실리테이터 1명 (중요!)

### 1단계: Big Picture Event Storming (전체 흐름 파악)

**목표**: 비즈니스 전체 프로세스를 빠르게 이해

#### 도메인 이벤트 발산 (15-30분)

퍼실리테이터가 다음과 같이 안내합니다:

```
"이 시스템에서 발생하는 모든 사건을 생각나는 대로 주황색 스티커에 적어주세요.
순서는 신경 쓰지 말고, 과거 시제로 작성해주세요."
```

**진행 방법**:
1. 각자 5분간 조용히 이벤트를 작성
2. 작성한 이벤트를 벽에 붙이며 간단히 설명
3. 비슷한 이벤트를 그룹화하거나 중복 제거

#### 시간 순서 정렬 (20-40분)

이벤트를 **시간 흐름에 따라 왼쪽에서 오른쪽**으로 정렬합니다:

```
[시작]                                                    [끝]
┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
│주문 생성│ → │재고 확인│ → │결제 완료│ → │상품 포장│ → │배송 완료│
└────────┘    └────────┘    └────────┘    └────────┘    └────────┘
```

**팁**:
- 병렬 프로세스는 위아래로 배치
- 순서가 불명확하면 빨간색 핫스팟 표시

#### 핫스팟 표시 (10-20분)

다음과 같은 경우 빨간색 스티커를 붙입니다:

```markdown
🟥 핫스팟이 필요한 경우:
- 논의가 필요한 비즈니스 규칙
- 불명확한 프로세스
- 예외 상황 처리
- 성능/보안 우려사항
```

예시:
```
"동시에 같은 상품을 여러 명이 주문하면?"
"결제 실패 후 재시도 로직은?"
```

### 2단계: Process Level Event Storming (상세 분석)

**목표**: 각 프로세스를 상세하게 모델링

#### 커맨드와 액터 추가

각 이벤트 앞에 **누가(액터) 무엇을(커맨드)** 했는지 추가합니다:

```
┌────────┐    ┌──────┐    ┌────────┐
│  고객  │ → │주문 생성│ → │주문 생성됨│
│(노란색)│    │(파란색)│    │(주황색) │
└────────┘    └──────┘    └────────┘
```

#### 읽기 모델 추가

커맨드 실행 시 필요한 정보를 초록색으로 표시합니다:

```
┌────────┐
│재고 현황│ (읽기 모델)
│(초록색)│
└────┬───┘
     ↓
┌──────┐    ┌────────┐
│재고 확인│ → │재고 확인됨│
│(파란색)│    │(주황색) │
└──────┘    └────────┘
```

#### 정책과 자동화 규칙 추가

조건에 따라 자동 실행되는 로직을 보라색으로 표시합니다:

```
┌────────┐
│재고 확인됨│
└────┬───┘
     ↓
┌──────────────────┐
│만약 재고 < 10이면 │
│자동 발주 실행     │ (정책)
│(보라색)          │
└────┬─────────────┘
     ↓
┌────────┐
│발주 요청됨│
└────────┘
```

#### 외부 시스템 연동 표시

외부 서비스와의 통신을 핑크색으로 표시합니다:

```
┌──────┐    ┌────────┐    ┌────────┐
│결제 요청│ → │  PG사   │ → │결제 완료됨│
└──────┘    │(핑크색) │    └────────┘
            └────────┘
```

### 3단계: 소프트웨어 설계 (Design Level)

**목표**: 시스템 경계와 아키텍처 도출

#### 애그리게잇 식별

관련된 이벤트와 커맨드를 묶어 애그리게잇을 정의합니다:

```
┌───────────────────────────────────┐
│      주문 애그리게잇 (Order)       │
├───────────────────────────────────┤
│ 이벤트: 주문생성됨, 주문취소됨     │
│ 커맨드: 주문생성, 주문취소         │
│ 속성: 주문ID, 고객ID, 상품목록    │
└───────────────────────────────────┘
```

#### 바운디드 컨텍스트 그리기

큰 점선으로 시스템 경계를 구분합니다:

```
┌─────────────────────┐  ┌─────────────────────┐
│  주문 관리 컨텍스트 │  │  재고 관리 컨텍스트 │
│                     │  │                     │
│ - 주문 생성         │  │ - 재고 차감         │
│ - 주문 취소         │  │ - 재고 보충         │
└─────────────────────┘  └─────────────────────┘
```

## 실전 예제: OMS 시스템

실제 OMS(Order Management System)를 Event Storming으로 모델링해봅니다.

### 전체 프로세스 흐름

```
[고객 주문] → [재고 관리] → [결제] → [포장] → [배송] → [완료]
```

### 상세 이벤트 플로우

#### 1. 주문 생성 단계

```
고객(노란색)
  ↓
주문 생성(파란색) ← 상품 재고(초록색)
  ↓
주문 생성됨(주황색)
  ↓
┌────────────────────────┐
│ 정책: 재고 10개 미만이면│
│ 자동 발주 알림 발송     │ (보라색)
└────────────────────────┘
  ↓
재고 부족 알림 발송됨(주황색)
```

#### 2. 재고 확인 및 차감

```
주문 생성됨(주황색)
  ↓
재고 확인(파란색)
  ↓
재고 확인됨(주황색)
  ↓
┌────────────────────────┐
│ 정책: 재고 있으면       │
│ 자동으로 재고 차감     │ (보라색)
└────────────────────────┘
  ↓
재고 차감됨(주황색)
```

**핫스팟 예시**:
```
🟥 동시 주문 시 재고 경쟁 조건
🟥 재고 차감 실패 시 주문 롤백 방법
```

#### 3. 결제 처리

```
재고 차감됨(주황색)
  ↓
결제 요청(파란색)
  ↓
┌────────────────────────┐
│ PG사 결제 API 호출     │ (핑크색)
└────────────────────────┘
  ↓
결제 완료됨(주황색) / 결제 실패됨(주황색)
```

**예외 플로우**:
```
결제 실패됨(주황색)
  ↓
┌────────────────────────┐
│ 정책: 자동으로 재고 복구│ (보라색)
└────────────────────────┘
  ↓
재고 복구됨(주황색)
  ↓
주문 취소됨(주황색)
```

#### 4. 포장 및 배송

```
결제 완료됨(주황색)
  ↓
포장 지시(파란색)
  ↓
상품 포장됨(주황색)
  ↓
배송사 연동(핑크색)
  ↓
배송 시작됨(주황색)
  ↓
배송 완료됨(주황색)
```

### 바운디드 컨텍스트 식별

OMS를 다음과 같이 컨텍스트로 나눌 수 있습니다:

```
┌───────────────────────────┐
│   주문 컨텍스트 (Order)   │
│                           │
│ - 주문 생성               │
│ - 주문 취소               │
│ - 주문 상태 조회          │
└───────────┬───────────────┘
            │
            │ 이벤트 발행
            ↓
┌───────────────────────────┐
│  재고 컨텍스트 (Inventory)│
│                           │
│ - 재고 확인               │
│ - 재고 차감               │
│ - 재고 보충               │
└───────────┬───────────────┘
            │
            │ 이벤트 발행
            ↓
┌───────────────────────────┐
│  배송 컨텍스트 (Shipping) │
│                           │
│ - 포장 지시               │
│ - 배송 시작               │
│ - 배송 추적               │
└───────────────────────────┘
```

**컨텍스트 간 통신**:
- 이벤트 기반 비동기 통신 (Event-Driven Architecture)
- 각 컨텍스트는 독립적으로 배포 가능 (마이크로서비스)

## 팁과 모범 사례

### 퍼실리테이터의 역할

**해야 할 일**:
- 타임키핑과 진행 속도 조절
- 모든 참여자가 발언하도록 유도
- 기술적 논쟁을 적절히 차단하고 핫스팟 표시
- 명확한 질문으로 논의 방향 제시

**하지 말아야 할 일**:
- 정답을 제시하거나 주도하지 않기
- 특정 참가자의 의견을 무시하지 않기
- 너무 빨리 결론 내리지 않기

### 효과적인 이벤트 작성

```markdown
✅ 구체적으로 작성:
- "주문이 생성됨" ✅
- "무언가 발생함" ❌

✅ 비즈니스 언어 사용:
- "주문이 생성됨" ✅
- "Order 엔티티가 DB에 저장됨" ❌

✅ 한 스티커에 하나의 이벤트:
- "결제가 완료됨" ✅
- "결제 완료 및 재고 차감됨" ❌
```

### 시간 관리

**추천 일정** (총 4시간):
- Big Picture: 2시간
- Process Level: 1.5시간
- 정리 및 액션 아이템: 30분

**휴식**:
- 1시간마다 10분 휴식
- 간식과 음료 준비 (에너지 유지)

### 온라인 vs 오프라인

| 구분 | 오프라인 | 온라인 |
|------|----------|--------|
| 장점 | 직관적, 자유로운 배치 | 원격 참여 가능, 자동 저장 |
| 단점 | 사진 촬영 필요 | 도구 학습 필요, 동시 편집 제한 |
| 추천 도구 | 포스트잇 + 긴 벽면 | Miro, FigJam |

## 흔한 실수와 해결법

### 실수 1: 기술 용어 사용

```markdown
❌ 잘못된 예:
- "데이터베이스에 INSERT됨"
- "API 호출이 성공함"
- "트랜잭션이 커밋됨"

✅ 올바른 예:
- "주문이 기록됨"
- "고객 정보가 확인됨"
- "변경사항이 저장됨"
```

**해결법**: 비즈니스 담당자가 이해할 수 있는 언어로 작성

### 실수 2: 너무 상세한 수준

```markdown
❌ Big Picture 단계에서 너무 상세:
"주문 생성됨" → "주문 검증됨" → "주문 번호 생성됨" → "주문 이메일 발송됨" → ...

✅ Big Picture는 큰 흐름만:
"주문 생성됨" → "재고 확인됨" → "결제 완료됨" → "배송 시작됨"
```

**해결법**: 처음에는 큰 그림만, 이후 단계에서 상세화

### 실수 3: 순서에 집착

```markdown
❌ 순서 논쟁:
"이 이벤트가 먼저야!" vs "아니야, 저게 먼저야!"
(30분 동안 순서 논쟁...)

✅ 불확실하면 핫스팟:
🟥 "이벤트 A와 B의 순서가 불명확함 - 나중에 논의"
```

**해결법**: Big Picture 단계에서는 대략적 순서만, 핫스팟으로 표시 후 진행

### 실수 4: 완벽주의

```markdown
❌ 모든 예외 케이스를 다 다루려고 함:
"만약 A가 B일 때..."
"근데 C가 D라면..."
(끝없는 예외 케이스 논의)

✅ 핵심 플로우에 집중:
주요 시나리오만 모델링하고, 예외는 핫스팟으로 표시
```

**해결법**: "80%의 케이스만 다루고, 나머지는 나중에" 원칙

### 실수 5: 개발자 위주 진행

```markdown
❌ 개발자가 주도:
"이건 API로 처리하고..."
"여기서 비동기로..."

✅ 도메인 전문가가 주도:
"고객이 주문하면..."
"재고가 부족하면..."
```

**해결법**: 퍼실리테이터가 비즈니스 언어 사용을 독려

## 다음 단계

### Event Storming 결과 활용

워크숍 후에는 다음과 같이 활용합니다:

1. **유비쿼터스 언어 정리**
   - 이벤트 이름 → 용어 사전 작성
   - 팀 전체가 동일한 용어 사용

2. **시스템 설계**
   - 바운디드 컨텍스트 → 마이크로서비스 경계
   - 애그리게잇 → DDD 모델링

3. **개발 우선순위**
   - 핵심 플로우부터 개발
   - 핫스팟은 기술 스파이크로 해결

4. **테스트 시나리오**
   - 이벤트 플로우 → E2E 테스트 시나리오
   - 예외 상황 → 예외 처리 테스트

### 관련 기법

Event Storming과 함께 사용하면 좋은 기법:

- **Domain-Driven Design (DDD)**: 애그리게잇, 엔티티, 값 객체 설계
- **Event-Driven Architecture**: 이벤트 기반 시스템 구축
- **User Story Mapping**: 사용자 여정과 이벤트 연결
- **C4 Model**: 시스템 아키텍처 문서화

## 더 알아보기

**추천 학습 자료**:

- [EventStorming.com](https://www.eventstorming.com/) - Alberto Brandolini 공식 사이트
- [Introducing EventStorming](https://leanpub.com/introducing_eventstorming) - 공식 책
- [Miro EventStorming Template](https://miro.com/miroverse/event-storming/)

**온라인 도구**:
- [Miro](https://miro.com/) - 협업 화이트보드
- [FigJam](https://www.figma.com/figjam/) - Figma 협업 도구

**커뮤니티**:
- DDD Community Korea
- EventStorming 한국 사용자 모임 (LinkedIn)

### 심화 학습

Event Storming을 마스터한 후 다음을 학습하세요:

1. **Domain-Driven Design 전략적 설계**
   - 바운디드 컨텍스트 매핑
   - 컨텍스트 맵

2. **Event Sourcing**
   - 이벤트를 시스템 상태의 소스로 사용
   - 이벤트 스토어 구축

3. **CQRS (Command Query Responsibility Segregation)**
   - 읽기/쓰기 모델 분리
   - 이벤트 기반 동기화

---

## 요약

Event Storming은 **빠르고 효과적인 비즈니스 모델링 기법**입니다. 핵심은:

1. **색상별 스티커로 시각화** - 누구나 이해하기 쉽게
2. **협업을 통한 지식 공유** - 팀 전체가 도메인 이해
3. **이벤트 중심 사고** - 비즈니스 관점에서 시스템 설계

OMS, WMS 같은 복잡한 시스템도 Event Storming으로 명확하게 정리할 수 있습니다. 팀과 함께 워크숍을 진행해보세요!
