---
title: 'Git Flow 워크플로우 완벽 가이드'
date: '2026-01-16'
description: 'Git Flow는 Vincent Driessen이 2010년에 제안한 브랜치 관리 전략으로, 체계적인 소프트웨어 버전 관리와 출시를 위해 설계되었습니다. 이 워크플로우는 5가지 브랜치 타입을 활용하여 기능 개발, 출시 준비, 긴급 버그 수정을 명확하게 분리합니다.'
tags: ['Git', 'Workflow', 'Git Flow', 'branch', '가이드', 'Best Practices', '버전 관리']
---

import { JsonLd } from '~/app/_components'

<JsonLd
  metadata={{
    title: 'Git Flow 워크플로우 완벽 가이드',
    description: 'Git Flow는 Vincent Driessen이 2010년에 제안한 브랜치 관리 전략으로, 체계적인 소프트웨어 버전 관리와 출시를 위해 설계되었습니다. 이 워크플로우는 5가지 브랜치 타입을 활용하여 기능 개발, 출시 준비, 긴급 버그 수정을 명확하게 분리합니다.',
    date: '2026-01-16',
    slug: 'git-flow-complete-guide',
    tags: ['Git', 'Workflow', 'Git Flow', 'branch', '가이드', 'Best Practices', '버전 관리'],
  }}
/>

## 개요

Git Flow는 Vincent Driessen이 2010년에 제안한 브랜치 관리 전략으로, 체계적인 소프트웨어 버전 관리와 출시를 위해 설계되었습니다. 이 워크플로우는 5가지 브랜치 타입을 활용하여 기능 개발, 출시 준비, 긴급 버그 수정을 명확하게 분리합니다.

Git Flow를 이해하면 팀 협업 시 브랜치 충돌을 줄이고, 명확한 버전 관리와 안정적인 배포 프로세스를 구축할 수 있습니다. 특히 정기적인 릴리즈 주기를 가진 프로젝트나 여러 버전을 동시에 지원해야 하는 소프트웨어에 적합합니다.

## 배경

### 왜 Git Flow가 등장했는가?

2010년 이전, Git 사용자들은 브랜치를 자유롭게 생성하고 병합할 수 있었지만, 팀 단위로 일관된 브랜치 전략을 수립하는 것은 어려운 과제였습니다. 특히 다음과 같은 문제들이 자주 발생했습니다:

- 여러 개발자가 동시에 작업할 때 브랜치 충돌
- 배포 준비 상태와 개발 중인 코드의 혼재
- 긴급 버그 수정 시 개발 중인 기능과의 분리 어려움
- 명확한 버전 관리의 부재

Vincent Driessen은 이러한 문제를 해결하기 위해 체계적인 브랜치 구조와 명확한 역할 분담을 제시했습니다.

### Git Flow 이전의 방식

Git Flow가 등장하기 전에는 대부분 다음 중 하나의 방식을 사용했습니다:

**1. 중앙집중식 워크플로우**
- 모든 개발자가 main 브랜치에서 직접 작업
- 충돌이 빈번하고 안정성 보장 어려움

**2. Feature Branch 워크플로우**
- 기능별로 브랜치를 생성하지만 명확한 규칙 부재
- 배포 시점과 버전 관리가 모호함

**3. Fork & Pull Request**
- 오픈소스에는 적합하지만 팀 내부 협업에는 과도하게 복잡

## Git Flow의 핵심 구조

Git Flow는 5가지 브랜치 타입으로 구성됩니다. 각 브랜치는 명확한 역할과 생명주기를 가집니다.

### 1. 영구 브랜치 (Main Branches)

#### Main (Master) 브랜치
- **역할**: 프로덕션 배포 가능한 안정적인 코드
- **특징**:
  - 모든 커밋은 배포 가능한 상태
  - 각 병합 시점마다 버전 태그 추가 (v1.0.0, v2.1.5 등)
  - 직접 커밋 금지, 오직 release 또는 hotfix 브랜치에서만 병합

#### Develop 브랜치
- **역할**: 다음 릴리즈를 위한 개발 통합 브랜치
- **특징**:
  - 모든 기능 개발의 시작점이자 목적지
  - 항상 최신 개발 상태 유지
  - feature 브랜치들이 병합되는 곳

### 2. 보조 브랜치 (Supporting Branches)

#### Feature 브랜치
- **목적**: 새로운 기능 개발
- **생성 기준**: develop 브랜치에서 분기
- **병합 대상**: develop 브랜치로 병합
- **네이밍**: `feature/기능명` 또는 `feature/이슈번호-기능명`
- **생명주기**: 기능 개발 완료 시 삭제

**예시**:
```bash
feature/user-authentication
feature/123-payment-integration
feature/dark-mode
```

#### Release 브랜치
- **목적**: 출시 준비 및 최종 테스트
- **생성 기준**: develop 브랜치에서 분기
- **병합 대상**: main과 develop 양쪽 모두
- **네이밍**: `release/버전번호`
- **특징**:
  - 버그 수정만 허용, 새 기능 추가 금지
  - 버전 번호 업데이트, 문서화 작업 수행
  - QA 테스트 진행

**예시**:
```bash
release/1.0.0
release/2.3.0
```

#### Hotfix 브랜치
- **목적**: 프로덕션 긴급 버그 수정
- **생성 기준**: main 브랜치에서 직접 분기
- **병합 대상**: main과 develop 양쪽 모두
- **네이밍**: `hotfix/버전번호` 또는 `hotfix/버그명`
- **특징**:
  - 개발 중인 기능과 독립적으로 처리
  - 빠른 패치 배포 가능
  - 마이너/패치 버전 증가

**예시**:
```bash
hotfix/1.0.1
hotfix/critical-security-patch
```

## Git Flow 동작 원리

### 1. 초기 설정

Git Flow를 시작하려면 먼저 develop 브랜치를 생성합니다:

```bash
# main 브랜치에서 시작
git checkout main

# develop 브랜치 생성
git checkout -b develop

# 원격 저장소에 push
git push -u origin develop
```

또는 git-flow 도구를 사용:

```bash
# git-flow 초기화
git flow init

# 대화형 프롬프트에서 기본값 설정
# - Production branch: main
# - Development branch: develop
# - Feature prefix: feature/
# - Release prefix: release/
# - Hotfix prefix: hotfix/
```

### 2. 기능 개발 워크플로우

```bash
# 1. Feature 브랜치 생성
git checkout develop
git checkout -b feature/user-profile

# 또는 git-flow 사용
git flow feature start user-profile

# 2. 기능 개발 및 커밋
git add .
git commit -m "feat: 사용자 프로필 페이지 UI 구현"
git commit -m "feat: 프로필 수정 API 연동"

# 3. 개발 완료 후 develop에 병합
git checkout develop
git merge --no-ff feature/user-profile

# 또는 git-flow 사용
git flow feature finish user-profile

# 4. 브랜치 삭제
git branch -d feature/user-profile
```

**핵심 포인트**:
- `--no-ff` 옵션으로 병합 커밋 생성 (히스토리 명확화)
- PR(Pull Request)을 통한 코드 리뷰 권장
- 여러 개발자가 동시에 다른 feature 브랜치에서 작업 가능

### 3. 릴리즈 준비 워크플로우

```bash
# 1. Release 브랜치 생성
git checkout develop
git checkout -b release/1.0.0

# 또는 git-flow 사용
git flow release start 1.0.0

# 2. 릴리즈 준비 작업
# - 버전 번호 업데이트 (package.json, build.gradle 등)
# - 문서 업데이트 (CHANGELOG.md, README.md)
# - 버그 수정 (새 기능 추가 금지!)

git commit -m "chore: 버전 1.0.0으로 업데이트"
git commit -m "docs: CHANGELOG 업데이트"
git commit -m "fix: QA에서 발견된 버그 수정"

# 3. Main 브랜치에 병합 및 태그
git checkout main
git merge --no-ff release/1.0.0
git tag -a v1.0.0 -m "Release version 1.0.0"

# 4. Develop 브랜치에도 병합 (릴리즈 중 수정사항 반영)
git checkout develop
git merge --no-ff release/1.0.0

# 또는 git-flow 사용 (위 3-4단계 자동 처리)
git flow release finish 1.0.0

# 5. 브랜치 삭제 및 push
git branch -d release/1.0.0
git push origin main develop --tags
```

### 4. 긴급 버그 수정 워크플로우

```bash
# 1. Hotfix 브랜치 생성 (main에서 분기)
git checkout main
git checkout -b hotfix/1.0.1

# 또는 git-flow 사용
git flow hotfix start 1.0.1

# 2. 버그 수정
git commit -m "fix: 결제 시스템 크리티컬 버그 수정"
git commit -m "chore: 버전 1.0.1로 업데이트"

# 3. Main 브랜치에 병합 및 태그
git checkout main
git merge --no-ff hotfix/1.0.1
git tag -a v1.0.1 -m "Hotfix version 1.0.1"

# 4. Develop 브랜치에도 병합
git checkout develop
git merge --no-ff hotfix/1.0.1

# 또는 git-flow 사용
git flow hotfix finish 1.0.1

# 5. 브랜치 삭제 및 push
git branch -d hotfix/1.0.1
git push origin main develop --tags
```

## 시각적 워크플로우

```
시간 →

main:     ─────●─────────────────●───────●─────→
                ↑                 ↑       ↑
              v1.0.0           v1.1.0  v1.1.1
                               (release) (hotfix)

develop:  ─────●───●───●───●───●───●───●─────→
                ↑   ↑   ↑   ↑   ↑   ↑   ↑
                │   │   │   │   │   │   └─ hotfix 병합
                │   │   │   │   │   └───── release 병합
                │   │   │   │   └───────── feature-3 병합
                │   │   │   └───────────── feature-2 병합
                │   │   └───────────────── feature-1 병합
                │   └───────────────────── 초기 분기
                └───────────────────────── main에서 분기

feature-1: ───●───●───●→ (develop에 병합)
              └───────────┘

feature-2:     ───●───●→ (develop에 병합)
               └───────┘

feature-3:         ───●───●───●→ (develop에 병합)
                   └───────────┘

release/1.1.0:           ───●───●→ (main, develop에 병합)
                         └───────┘

hotfix/1.1.1:                    ──●→ (main, develop에 병합)
                                 └──┘
```

## 실제 사용 사례

### 사례 1: 우아한형제들 배민앱

우아한형제들의 안드로이드 파트는 2017년부터 Git Flow를 도입했습니다.

**도입 배경**:
- 3주 주기의 정기 배포
- 기획-디자인-개발-QA-출시의 명확한 프로세스
- 여러 기능이 동시에 개발되는 환경

**적용 방식**:
```
1. JIRA 티켓 생성 → feature 브랜치 시작
2. 개발 완료 → develop에 PR
3. QA 시작 시점 → release 브랜치 생성
4. QA 통과 → main 병합 및 배포
5. 긴급 버그 → hotfix 브랜치로 즉시 대응
```

**결과**:
- 일관된 버전 관리
- 다양한 상황에 체계적으로 대응
- 브랜치 관리 부담 증가는 있었으나 전반적으로 안정성 향상

### 사례 2: React 라이브러리

React 팀은 Git Flow를 기반으로 버전 관리를 수행합니다:

**특징**:
- 명활한 Release Notes 제공
- Semantic Versioning (v18.2.0, v18.3.0)
- 각 버전의 변경사항 추적 용이

**릴리즈 프로세스**:
```bash
# 새 릴리즈 준비
git flow release start 18.3.0

# 변경사항 정리 및 문서화
# - Breaking Changes 명시
# - New Features 목록화
# - Bug Fixes 정리

# 릴리즈 완료
git flow release finish 18.3.0
npm publish
```

### 사례 3: 모바일 앱 (iOS/Android)

앱스토어에 배포되는 모바일 앱은 Git Flow의 대표적인 활용 사례입니다:

**앱 버전 관리**:
```
main: 앱스토어 배포 버전 (v2.1.0, v2.1.1, v2.2.0)
develop: 다음 릴리즈 개발 (v2.3.0-dev)
feature/social-login: 소셜 로그인 기능 개발
feature/push-notification: 푸시 알림 기능 개발
release/2.2.0: 2.2.0 릴리즈 QA 진행
hotfix/2.1.1: 크래시 버그 긴급 수정
```

**장점**:
- 여러 버전이 동시에 사용자 기기에 존재
- 앱스토어 심사 기간 중에도 다음 버전 개발 가능
- 긴급 패치 신속 대응

## 장점과 한계

### ✅ 장점

#### 1. 명확한 버전 관리
버전별로 어떤 기능이 포함되었는지 명확하게 추적할 수 있습니다. main 브랜치의 각 태그가 릴리즈 버전을 나타내므로, 특정 버전의 코드로 쉽게 돌아갈 수 있습니다.

```bash
# v1.5.0에서 버그 재현 확인
git checkout v1.5.0
npm install
npm start
```

#### 2. 병렬 개발 가능
여러 개발자가 서로 다른 feature 브랜치에서 독립적으로 작업하므로, 다른 개발자의 작업에 영향을 받지 않습니다.

```
개발자 A: feature/payment → develop
개발자 B: feature/user-profile → develop
개발자 C: feature/notification → develop
(모두 동시 진행 가능, 충돌 최소화)
```

#### 3. 안정적인 프로덕션 환경
main 브랜치는 항상 배포 가능한 상태를 유지하므로, 프로덕션 환경의 안정성이 보장됩니다. 개발 중인 불안정한 코드가 프로덕션에 영향을 주지 않습니다.

#### 4. 긴급 대응 프로세스
hotfix 브랜치를 통해 개발 중인 기능과 독립적으로 버그를 수정할 수 있습니다. 다음 릴리즈를 기다리지 않고 즉시 패치 배포가 가능합니다.

#### 5. 체계적인 릴리즈 관리
release 브랜치에서 QA와 릴리즈 준비를 진행하는 동안, develop 브랜치에서는 다음 버전 개발을 계속할 수 있습니다.

### ⚠️ 한계

#### 1. 복잡성
5가지 브랜치 타입을 이해하고 올바르게 사용하려면 학습 곡선이 있습니다. 특히 Git 초보자에게는 진입 장벽이 높을 수 있습니다.

**복잡도 비교**:
```
GitHub Flow:  main + feature (2개 브랜치 타입)
Git Flow:     main + develop + feature + release + hotfix (5개)
```

#### 2. 과도한 브랜치 관리
작은 팀이나 단순한 프로젝트에서는 불필요하게 복잡할 수 있습니다. 브랜치 생성, 병합, 삭제 과정이 반복되어 관리 오버헤드가 발생합니다.

#### 3. 잦은 배포에 부적합
웹 애플리케이션처럼 하루에도 여러 번 배포하는 환경에서는 Git Flow의 release 브랜치 과정이 오히려 배포 속도를 늦출 수 있습니다.

**Vincent Driessen의 2020년 업데이트**:
> "웹 애플리케이션은 지속적으로 배포되며, 롤백하지 않고, 여러 버전을 동시에 지원할 필요가 없습니다. 이것은 제가 10년 전에 염두에 둔 소프트웨어 유형이 아닙니다."

#### 4. 여러 번의 병합
release와 hotfix 브랜치는 main과 develop 양쪽에 모두 병합해야 하므로, 실수로 한쪽을 빠뜨릴 위험이 있습니다.

```bash
# 잊기 쉬운 단계
git checkout main
git merge --no-ff hotfix/1.0.1  # ✅
git checkout develop
git merge --no-ff hotfix/1.0.1  # ❌ 잊어버리기 쉬움!
```

## 적용 가이드

### Git Flow가 적합한 경우

#### ✅ 명시적 버전 관리가 필요한 프로젝트
- **모바일 앱** (iOS, Android)
- **데스크톱 애플리케이션**
- **임베디드 소프트웨어**
- **오픈소스 라이브러리/프레임워크**

**이유**: 여러 버전이 동시에 사용자 환경에 존재하므로, 각 버전을 명확히 구분하고 관리해야 합니다.

#### ✅ 정기적인 릴리즈 주기
- 2주~1개월 단위의 정기 배포
- 릴리즈별로 기능을 묶어서 출시
- QA 프로세스가 확립된 조직

**예시**: 배민앱 (3주 주기), 게임 업데이트 (월간)

#### ✅ 대규모 팀 또는 복잡한 프로젝트
- 10명 이상의 개발자
- 여러 기능이 병렬로 개발
- 명확한 역할 분담 필요

### Git Flow가 부적합한 경우

#### ❌ 지속적 배포 (Continuous Deployment)
- 하루 여러 번 프로덕션 배포
- 기능이 완성되는 즉시 배포
- 작은 단위의 빠른 반복

**대안**: GitHub Flow, Trunk-Based Development

#### ❌ 웹 애플리케이션 (SaaS)
- 사용자가 항상 최신 버전만 사용
- 버전 관리가 불필요
- 빠른 피드백 루프 중시

**예시**:
```
❌ Git Flow
main → release/1.2.0 → QA → main 병합 → 배포
(시간 소요: 3-5일)

✅ GitHub Flow
feature → PR → 리뷰 → main 병합 → 자동 배포
(시간 소요: 수시간)
```

#### ❌ 소규모 팀 (<5명)
- 팀원 모두가 프로젝트 전체를 파악
- 커뮤니케이션이 긴밀
- 복잡한 프로세스가 오히려 생산성 저하

## Git Flow vs GitHub Flow

### 비교표

| 항목 | Git Flow | GitHub Flow |
|-----|----------|-------------|
| **브랜치 수** | 5개 (main, develop, feature, release, hotfix) | 2개 (main, feature) |
| **복잡도** | 높음 | 낮음 |
| **배포 주기** | 정기 배포 (주/월 단위) | 지속적 배포 (수시) |
| **적합한 프로젝트** | 모바일 앱, 패키지 라이브러리 | 웹 애플리케이션, SaaS |
| **학습 곡선** | 가파름 | 완만함 |
| **버전 관리** | 명시적 (태그 활용) | 암묵적 (커밋 기반) |
| **QA 프로세스** | release 브랜치에서 진행 | main 병합 전 PR에서 진행 |

### 의사결정 플로우차트

```
프로젝트 유형은?
│
├─ 모바일 앱, 데스크톱 SW, 라이브러리
│  └─→ Git Flow 권장
│
├─ 웹 애플리케이션, SaaS
│  │
│  └─ 배포 주기는?
│     │
│     ├─ 정기 배포 (주/월 단위)
│     │  └─→ Git Flow 또는 단순화된 변형
│     │
│     └─ 지속적 배포 (수시)
│        └─→ GitHub Flow 권장
│
└─ 팀 규모는?
   │
   ├─ 10명 이상
   │  └─→ Git Flow로 명확한 프로세스 확립
   │
   └─ 5명 이하
      └─→ GitHub Flow로 단순하게 시작
```

## 실전 팁

### 1. 커밋 메시지 규칙

Git Flow를 효과적으로 사용하려면 일관된 커밋 메시지 컨벤션이 필수입니다:

```bash
# Conventional Commits 형식 권장
<타입>: <제목>

<본문>

<푸터>
```

**타입 예시**:
```bash
feat: 새로운 기능 추가
fix: 버그 수정
docs: 문서 수정
style: 코드 포맷팅 (기능 변경 없음)
refactor: 코드 리팩토링
test: 테스트 코드 추가
chore: 빌드 관련 수정
```

**실제 예시**:
```bash
feat: 사용자 프로필 페이지 구현

- 프로필 정보 조회 API 연동
- 프로필 이미지 업로드 기능
- 프로필 수정 UI 구현

Closes #123
```

### 2. PR(Pull Request) 활용

feature 브랜치를 develop에 병합할 때는 PR을 활용하세요:

```bash
# feature 브랜치 push
git push -u origin feature/user-authentication

# GitHub에서 PR 생성
# - Base: develop
# - Compare: feature/user-authentication
# - Reviewers: 팀원 지정
# - Labels: feature, enhancement 등
```

**PR 템플릿 예시**:
```markdown
## 변경 사항
- 사용자 인증 기능 구현
- JWT 토큰 기반 인증

## 테스트
- [ ] 단위 테스트 통과
- [ ] 통합 테스트 통과
- [ ] 수동 테스트 완료

## 스크린샷
[로그인 화면 스크린샷]

## 관련 이슈
Closes #123
```

### 3. Semantic Versioning

버전 번호는 Semantic Versioning을 따르세요:

```
MAJOR.MINOR.PATCH

예: 2.1.5
- MAJOR (2): Breaking Changes (호환성 깨지는 변경)
- MINOR (1): 새로운 기능 추가 (하위 호환성 유지)
- PATCH (5): 버그 수정
```

**실제 적용**:
```bash
# 새 기능 추가 → MINOR 증가
v1.2.0 → feature 추가 → v1.3.0

# 버그 수정 → PATCH 증가
v1.3.0 → hotfix → v1.3.1

# Breaking Change → MAJOR 증가
v1.3.1 → API 변경 → v2.0.0
```

### 4. CHANGELOG.md 관리

각 릴리즈마다 변경사항을 문서화하세요:

```markdown
# Changelog

## [2.1.0] - 2024-12-22

### Added
- 사용자 프로필 페이지 (#123)
- 다크 모드 지원 (#145)

### Fixed
- 결제 시스템 버그 수정 (#167)

### Changed
- 로그인 UI 개선 (#189)

## [2.0.0] - 2024-11-15

### Breaking Changes
- API 엔드포인트 변경
  - `/api/users` → `/api/v2/users`

### Added
- 소셜 로그인 기능
```

### 5. 브랜치 보호 규칙

GitHub/GitLab에서 브랜치 보호 설정:

```
main 브랜치:
✅ PR 필수
✅ 최소 1명 이상의 승인 필요
✅ CI 통과 필수
✅ 직접 push 금지

develop 브랜치:
✅ PR 필수
✅ CI 통과 필수
```

### 6. Git Flow 도구 활용

**git-flow CLI 설치**:
```bash
# macOS
brew install git-flow

# Ubuntu
apt-get install git-flow

# Windows
# Git for Windows에 포함됨
```

**주요 명령어**:
```bash
# 초기화
git flow init

# Feature
git flow feature start 기능명
git flow feature finish 기능명

# Release
git flow release start 1.0.0
git flow release finish 1.0.0

# Hotfix
git flow hotfix start 1.0.1
git flow hotfix finish 1.0.1
```

### 7. CI/CD 파이프라인 구성

```yaml
# GitHub Actions 예시
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run tests
        run: npm test

  deploy-staging:
    needs: test
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to staging
        run: ./deploy-staging.sh

  deploy-production:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to production
        run: ./deploy-production.sh
```

## 트러블슈팅

### 문제 1: release/hotfix를 develop에 병합하는 것을 잊음

**증상**:
- hotfix/1.0.1에서 수정한 버그가 develop에서 다시 발생
- release 중 수정한 버그가 다음 릴리즈에 포함되지 않음

**해결 방법**:
```bash
# 누락된 병합 확인
git log develop --not main

# develop에 병합
git checkout develop
git merge --no-ff hotfix/1.0.1
git push origin develop
```

**예방**:
- git-flow 도구 사용 (자동으로 양쪽 병합)
- PR 체크리스트에 "develop 병합 확인" 항목 추가

### 문제 2: 잘못된 브랜치에서 작업 시작

**증상**:
```bash
# develop이 아닌 feature에서 새 feature 시작
git checkout feature/old-feature
git checkout -b feature/new-feature  # ❌ 잘못된 베이스!
```

**해결 방법**:
```bash
# 새 feature 브랜치를 develop 기준으로 재생성
git checkout develop
git checkout -b feature/new-feature-correct

# 이전 작업 내용을 cherry-pick
git cherry-pick <commit-hash>
```

**예방**:
- 항상 `git status`로 현재 브랜치 확인
- feature 시작 전 develop으로 이동하는 습관

### 문제 3: release 중 새 기능 추가 요청

**증상**:
- release/1.0.0 브랜치에서 QA 진행 중
- 긴급하게 새 기능을 추가해달라는 요청

**해결 방법**:

**옵션 1: 다음 릴리즈로 연기 (권장)**
```bash
# 현재 릴리즈는 그대로 진행
git flow release finish 1.0.0

# 새 기능은 다음 릴리즈에 포함
git checkout develop
git checkout -b feature/new-urgent-feature
```

**옵션 2: 릴리즈 취소 후 재시작**
```bash
# release 브랜치 삭제
git branch -D release/1.0.0

# develop에 새 기능 추가
git checkout develop
git checkout -b feature/new-urgent-feature
# ... 개발 및 병합

# 새로운 release 시작
git flow release start 1.0.0
```

### 문제 4: main과 develop의 커밋 히스토리 불일치

**증상**:
- main에 있는 hotfix가 develop에 없음
- 두 브랜치의 히스토리가 크게 다름

**해결 방법**:
```bash
# develop을 main 기준으로 동기화 (주의!)
git checkout develop
git merge --no-ff main

# 충돌 해결 후 푸시
git push origin develop
```

**예방**:
- 모든 hotfix와 release를 양쪽에 병합
- 정기적으로 main과 develop 동기화 상태 확인

## 팀 도입 가이드

### 1단계: 팀 교육 (1-2주)

```
Day 1-3: Git 기초 복습
- 브랜치, 병합, 리베이스
- 충돌 해결

Day 4-7: Git Flow 이론
- 5가지 브랜치 타입
- 워크플로우 이해
- 실습 프로젝트

Day 8-10: 도구 및 프로세스
- git-flow CLI 사용법
- PR 프로세스
- CI/CD 파이프라인
```

### 2단계: 파일럿 프로젝트 (2-4주)

```
Week 1: 소규모 기능 개발
- feature 브랜치 생성/병합 연습
- PR 리뷰 프로세스 적용

Week 2: 릴리즈 프로세스
- release 브랜치 생성
- QA 진행
- main 배포

Week 3-4: 피드백 및 개선
- 어려웠던 점 논의
- 프로세스 조정
- 문서화
```

### 3단계: 전체 도입 및 모니터링

```
Month 1: 전체 팀 적용
- 모든 프로젝트에 Git Flow 적용
- 주간 회고 진행

Month 2-3: 최적화
- 병목 지점 개선
- 자동화 확대
- 베스트 프랙티스 공유
```

## 관련 자료

### 공식 문서
- [Vincent Driessen의 원본 블로그 글](https://nvie.com/posts/a-successful-git-branching-model/)
- [Atlassian Git Flow 가이드](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)
- [git-flow 도구 GitHub](https://github.com/nvie/gitflow)

### 한국어 참고 자료
- [우아한형제들 기술블로그 - Git-flow 사용기](https://techblog.woowahan.com/2553/)
- [화해 블로그 - Git 브랜치 전략](https://blog.hwahae.co.kr/all/tech/9507)

### 도서
- *Pro Git* by Scott Chacon (무료 온라인)
- *Git Pocket Guide* by Richard E. Silverman

### 대안 워크플로우
- **GitHub Flow**: Git Flow의 단순화된 버전
- **GitLab Flow**: 환경별 브랜치 추가
- **Trunk-Based Development**: 단일 브랜치 중심
- **SimGit Flow**: 3단계 브랜치 전략

## 결론

Git Flow는 2010년 등장 이후 많은 조직에서 검증된 브랜치 전략입니다. 명시적인 버전 관리가 필요하고 정기적인 릴리즈 주기를 가진 프로젝트에 매우 적합합니다.

하지만 Vincent Driessen 본인도 2020년 업데이트에서 밝혔듯이, Git Flow가 모든 프로젝트에 최선은 아닙니다. 웹 애플리케이션처럼 지속적 배포가 필요한 경우에는 GitHub Flow나 Trunk-Based Development가 더 효율적일 수 있습니다.

**핵심 포인트**:
- ✅ 모바일 앱, 패키지 라이브러리 → Git Flow 권장
- ✅ 정기 배포, 명시적 버전 관리 → Git Flow 적합
- ⚠️ 웹 애플리케이션, 지속적 배포 → GitHub Flow 고려
- ⚠️ 소규모 팀, 단순한 프로젝트 → 단순한 전략 선택

**성공적인 도입을 위한 조언**:
1. 팀의 개발 프로세스와 배포 주기를 먼저 파악하세요
2. Git Flow를 교조적으로 따르지 말고 팀에 맞게 조정하세요
3. 도구(git-flow, CI/CD)를 활용하여 프로세스를 자동화하세요
4. 지속적으로 개선하고 팀의 피드백을 반영하세요

Git Flow는 도구일 뿐입니다. 팀의 생산성과 코드 품질을 높이는 것이 궁극적인 목표임을 잊지 마세요.

---

**버전**: 1.0.0
**작성일**: 2024년 12월 22일
**작성자**: Claude (Anthropic)
**기반 자료**: Vincent Driessen의 Git Flow, 우아한형제들 사례, 다양한 기술 블로그
