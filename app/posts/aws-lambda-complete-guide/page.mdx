---
title: "AWS Lambda 완전 가이드"
description: "AWS Lambda를 사용하면 서버를 관리하지 않고도 코드를 실행할 수 있습니다. 이 가이드에서는 Lambda의 핵심 개념을 이해하고, 첫 번째 Lambda 함수를 직접 작성하고 배포하는 방법을 알아봅니다."
date: 2025-01-31
tags: ["AWS", "Lambda", "Serverless", "Cloud Computing"]
---

AWS Lambda를 사용하면 서버를 관리하지 않고도 코드를 실행할 수 있습니다. 이 가이드에서는 Lambda의 핵심 개념을 이해하고, 첫 번째 Lambda 함수를 직접 작성하고 배포하는 방법을 알아봅니다.

## 개요

AWS Lambda는 서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스입니다. 이벤트에 응답하여 자동으로 실행되며, 사용한 컴퓨팅 시간에 대해서만 비용을 지불합니다.

Lambda를 사용하면 인프라 관리에 시간을 쓰지 않고 애플리케이션 로직 개발에 집중할 수 있습니다.

---

## 배경

### 왜 필요한가?

전통적인 서버 기반 아키텍처에서는 다음과 같은 문제가 있었습니다:

- **서버 관리 부담**: EC2 인스턴스를 직접 설정하고 관리해야 함
- **비효율적인 비용**: 사용하지 않을 때도 서버가 실행되어 비용 발생
- **스케일링 복잡도**: 트래픽 변화에 따라 수동으로 서버를 추가/제거해야 함
- **유휴 리소스**: 피크 타임을 대비해 과도한 용량을 유지

Lambda는 이러한 문제를 해결하기 위해 등장했습니다.

### 등장 이전의 방식

Lambda 이전에는 간단한 작업을 처리하기 위해서도 다음 과정이 필요했습니다:

```bash
# 1. EC2 인스턴스 생성 및 설정
# 2. 운영체제 및 런타임 설치
# 3. 애플리케이션 코드 배포
# 4. 로드 밸런서 설정
# 5. 오토 스케일링 그룹 구성
# 6. 모니터링 및 로깅 설정
```

이제 Lambda를 사용하면 코드만 업로드하면 됩니다.

---

## 동작 원리

### 핵심 메커니즘

Lambda는 다음과 같은 방식으로 작동합니다:

1. **이벤트 트리거**: S3 업로드, API Gateway 요청, DynamoDB 변경 등의 이벤트가 발생
2. **함수 실행**: Lambda가 자동으로 컴퓨팅 리소스를 할당하고 코드를 실행
3. **자동 스케일링**: 동시 요청 수에 따라 자동으로 확장 (최대 1,000개 동시 실행)
4. **리소스 해제**: 실행 완료 후 리소스를 자동으로 해제

### 시각적 예시

```
[이벤트 발생]                    [Lambda 함수]
┌─────────────┐                ┌──────────────┐
│ API Request │  ──트리거──→   │  코드 실행   │
│ S3 Upload   │                │  (Node.js)   │
│ Schedule    │                │              │
└─────────────┘                └──────────────┘
                                      ↓
                               [결과 반환/저장]
                               ┌──────────────┐
                               │ DynamoDB     │
                               │ S3           │
                               │ SNS          │
                               └──────────────┘
```

### 실행 환경

Lambda 함수가 실행될 때 다음과 같은 환경이 제공됩니다:

```javascript
// Lambda 함수의 기본 구조
export const handler = async (event, context) => {
  // event: 함수를 트리거한 이벤트 데이터
  // context: 실행 환경 정보 (요청 ID, 남은 시간 등)

  console.log('받은 이벤트:', JSON.stringify(event));

  // 비즈니스 로직 처리
  const result = processData(event);

  // 응답 반환
  return {
    statusCode: 200,
    body: JSON.stringify(result)
  };
};
```

---

## 주요 특징

### 특징 1: 완전 관리형 서비스

서버, 운영체제, 패치 관리가 모두 자동화되어 있습니다.

**혜택**:
- 인프라 관리 시간 제로
- 보안 패치 자동 적용
- 고가용성 기본 제공

**코드 예시**:
```javascript
// 서버 설정 코드가 필요 없음
// 함수 코드만 작성하면 됨
export const handler = async (event) => {
  // 바로 비즈니스 로직 작성
  return { message: 'Hello from Lambda!' };
};
```

### 특징 2: 이벤트 기반 실행

70개 이상의 AWS 서비스와 통합되어 다양한 이벤트에 자동 응답합니다.

**주요 이벤트 소스**:
- **API Gateway**: REST/HTTP API 요청
- **S3**: 파일 업로드/삭제
- **DynamoDB**: 테이블 변경 사항
- **EventBridge**: 스케줄 기반 실행
- **SNS/SQS**: 메시지 처리

**예시**:
```javascript
// S3 이벤트 처리
export const handler = async (event) => {
  // S3에 이미지가 업로드되면 자동 실행
  const bucket = event.Records[0].s3.bucket.name;
  const key = event.Records[0].s3.object.key;

  console.log(`새 파일 업로드: ${bucket}/${key}`);

  // 이미지 썸네일 생성 로직
  await createThumbnail(bucket, key);

  return { success: true };
};
```

### 특징 3: 자동 스케일링

트래픽에 따라 자동으로 확장되며, 동시 실행 제한을 설정할 수 있습니다.

**스케일링 동작**:
```
요청 1개   → Lambda 인스턴스 1개 생성
요청 100개 → Lambda 인스턴스 100개 자동 생성
요청 0개   → 모든 인스턴스 자동 종료 (비용 0원)
```

### 특징 4: 사용량 기반 요금

코드가 실행되는 시간과 메모리 사용량에 대해서만 비용을 지불합니다.

**요금 계산**:
- **무료 티어**: 월 100만 건 요청, 40만 GB-초 컴퓨팅 시간
- **유료**: 요청당 $0.0000002, GB-초당 $0.0000166667

**비용 예시**:
```
메모리: 512MB
실행 시간: 100ms
월 요청: 100만 건

비용 = (100만 × $0.0000002) + (100만 × 0.1초 × 0.5GB × $0.0000166667)
     = $0.20 + $0.83
     = 약 $1.03/월
```

---

## 실제 사용 사례

### 사례 1: REST API 백엔드

**구성**:
```
사용자 요청 → API Gateway → Lambda → DynamoDB
```

**Lambda 함수 예시**:
```javascript
// API Gateway + Lambda로 REST API 구현
import { DynamoDBClient, GetItemCommand } from '@aws-sdk/client-dynamodb';

const client = new DynamoDBClient({ region: 'ap-northeast-2' });

export const handler = async (event) => {
  try {
    // API Gateway에서 전달된 경로 파라미터
    const userId = event.pathParameters.id;

    // DynamoDB에서 사용자 정보 조회
    const command = new GetItemCommand({
      TableName: 'Users',
      Key: { userId: { S: userId } }
    });

    const response = await client.send(command);

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify(response.Item)
    };
  } catch (error) {
    console.error('오류 발생:', error);

    return {
      statusCode: 500,
      body: JSON.stringify({ error: '서버 오류가 발생했습니다.' })
    };
  }
};
```

### 사례 2: 이미지 처리 파이프라인

S3에 이미지가 업로드되면 자동으로 썸네일을 생성하는 시나리오입니다.

**Lambda 함수**:
```javascript
import sharp from 'sharp';
import { S3Client, GetObjectCommand, PutObjectCommand } from '@aws-sdk/client-s3';

const s3Client = new S3Client({ region: 'ap-northeast-2' });

export const handler = async (event) => {
  // S3 이벤트에서 파일 정보 추출
  const record = event.Records[0];
  const bucket = record.s3.bucket.name;
  const key = decodeURIComponent(record.s3.object.key.replace(/\+/g, ' '));

  console.log(`처리 시작: ${bucket}/${key}`);

  try {
    // 원본 이미지 다운로드
    const getCommand = new GetObjectCommand({ Bucket: bucket, Key: key });
    const { Body } = await s3Client.send(getCommand);
    const imageBuffer = await streamToBuffer(Body);

    // 썸네일 생성 (300x300)
    const thumbnail = await sharp(imageBuffer)
      .resize(300, 300, { fit: 'cover' })
      .toBuffer();

    // 썸네일 업로드
    const thumbnailKey = `thumbnails/${key}`;
    const putCommand = new PutObjectCommand({
      Bucket: bucket,
      Key: thumbnailKey,
      Body: thumbnail,
      ContentType: 'image/jpeg'
    });

    await s3Client.send(putCommand);

    console.log(`썸네일 생성 완료: ${thumbnailKey}`);

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: '썸네일 생성 완료',
        thumbnail: thumbnailKey
      })
    };
  } catch (error) {
    console.error('이미지 처리 오류:', error);
    throw error;
  }
};

// 스트림을 버퍼로 변환
async function streamToBuffer(stream) {
  const chunks = [];
  for await (const chunk of stream) {
    chunks.push(chunk);
  }
  return Buffer.concat(chunks);
}
```

**배포 설정**:
```yaml
# serverless.yml
service: image-processor

provider:
  name: aws
  runtime: nodejs20.x
  region: ap-northeast-2
  environment:
    BUCKET_NAME: my-image-bucket

functions:
  processImage:
    handler: handler.handler
    memorySize: 1024  # 이미지 처리를 위해 메모리 증가
    timeout: 30       # 타임아웃 30초
    events:
      - s3:
          bucket: my-image-bucket
          event: s3:ObjectCreated:*
          rules:
            - prefix: uploads/
            - suffix: .jpg
```

### 사례 3: 스케줄 기반 데이터 처리

매일 자정에 데이터를 집계하고 리포트를 생성하는 예시입니다.

**Lambda 함수**:
```javascript
import { DynamoDBClient, ScanCommand } from '@aws-sdk/client-dynamodb';
import { SESClient, SendEmailCommand } from '@aws-sdk/client-ses';

const dynamoClient = new DynamoDBClient({ region: 'ap-northeast-2' });
const sesClient = new SESClient({ region: 'ap-northeast-2' });

export const handler = async (event) => {
  console.log('일일 리포트 생성 시작');

  try {
    // DynamoDB에서 오늘의 데이터 조회
    const today = new Date().toISOString().split('T')[0];
    const command = new ScanCommand({
      TableName: 'Orders',
      FilterExpression: 'begins_with(orderDate, :date)',
      ExpressionAttributeValues: {
        ':date': { S: today }
      }
    });

    const { Items } = await dynamoClient.send(command);

    // 통계 계산
    const stats = {
      totalOrders: Items.length,
      totalRevenue: Items.reduce((sum, item) =>
        sum + parseFloat(item.amount.N), 0
      ),
      avgOrderValue: 0
    };
    stats.avgOrderValue = stats.totalRevenue / stats.totalOrders;

    // 이메일 리포트 발송
    const emailCommand = new SendEmailCommand({
      Source: 'noreply@example.com',
      Destination: {
        ToAddresses: ['admin@example.com']
      },
      Message: {
        Subject: {
          Data: `일일 주문 리포트 - ${today}`
        },
        Body: {
          Html: {
            Data: `
              <h2>일일 주문 통계</h2>
              <ul>
                <li>총 주문 건수: ${stats.totalOrders}건</li>
                <li>총 매출: ${stats.totalRevenue.toFixed(2)}</li>
                <li>평균 주문 금액: ${stats.avgOrderValue.toFixed(2)}</li>
              </ul>
            `
          }
        }
      }
    });

    await sesClient.send(emailCommand);

    console.log('리포트 발송 완료:', stats);

    return {
      statusCode: 200,
      body: JSON.stringify({ message: '리포트 생성 완료', stats })
    };
  } catch (error) {
    console.error('리포트 생성 오류:', error);
    throw error;
  }
};
```

**EventBridge 스케줄 설정**:
```json
{
  "schedule": "cron(0 0 * * ? *)",
  "description": "매일 자정(UTC) 실행"
}
```

---

## 장점과 한계

### 장점

- ✅ **제로 서버 관리**: 인프라 걱정 없이 코드에만 집중
- ✅ **자동 스케일링**: 트래픽 변화에 자동 대응
- ✅ **비용 효율적**: 사용한 만큼만 지불, 유휴 시간 비용 없음
- ✅ **빠른 배포**: 코드 업로드만으로 즉시 배포 가능
- ✅ **높은 가용성**: 여러 가용 영역에 자동 분산
- ✅ **풍부한 통합**: 70개 이상의 AWS 서비스와 연동

### 한계

- ⚠️ **실행 시간 제한**: 최대 15분 (긴 작업에는 부적합)
- ⚠️ **콜드 스타트**: 첫 실행 시 지연 발생 (100ms ~ 수 초)
- ⚠️ **메모리 제한**: 최대 10GB
- ⚠️ **패키지 크기 제한**: 배포 패키지 최대 50MB (압축), 250MB (압축 해제)
- ⚠️ **디스크 공간 제한**: /tmp 디렉토리 최대 512MB ~ 10GB
- ⚠️ **상태 비저장**: 함수 간 상태 공유 불가 (외부 저장소 필요)

### 트레이드오프

**Lambda를 사용해야 하는 경우**:
- 이벤트 기반 처리 (API, 파일 업로드, 메시지 큐)
- 간헐적인 작업 (스케줄 작업, 배치 처리)
- 빠른 프로토타이핑
- 마이크로서비스 아키텍처

**Lambda를 피해야 하는 경우**:
- 15분 이상 실행되는 작업
- 지속적으로 높은 트래픽 (EC2가 더 경제적)
- 매우 낮은 지연 시간이 중요한 경우 (콜드 스타트 문제)
- 대용량 메모리가 필요한 작업 (10GB 이상)

---

## 첫 번째 Lambda 함수 만들기

### 사전 준비

- AWS 계정
- Node.js 18 이상
- AWS CLI 설치 및 설정
- 기본적인 JavaScript 지식

### 1단계: 간단한 Lambda 함수 작성

프로젝트 디렉토리를 생성하고 함수 코드를 작성하세요:

```bash
mkdir my-first-lambda
cd my-first-lambda
```

`index.js` 파일을 생성하세요:

```javascript
// index.js
export const handler = async (event) => {
  console.log('받은 이벤트:', JSON.stringify(event, null, 2));

  const name = event.name || 'World';
  const message = `Hello, ${name}!`;

  return {
    statusCode: 200,
    body: JSON.stringify({
      message: message,
      timestamp: new Date().toISOString()
    })
  };
};
```

### 2단계: AWS 콘솔에서 함수 생성

1. **AWS Lambda 콘솔** (https://console.aws.amazon.com/lambda) 접속
2. **함수 생성** 버튼 클릭
3. **함수 이름** 입력: `MyFirstFunction`
4. **런타임** 선택: Node.js 20.x
5. **함수 생성** 클릭

### 3단계: 코드 업로드

1. 함수 코드 섹션에서 위에서 작성한 코드 붙여넣기
2. **Deploy** 버튼 클릭

### 4단계: 테스트 이벤트 생성

1. **Test** 탭 클릭
2. **새 이벤트 생성**
3. 이벤트 이름: `TestEvent`
4. 이벤트 JSON 입력:

```json
{
  "name": "AWS Lambda"
}
```

5. **Save** 클릭

### 5단계: 함수 실행

1. **Test** 버튼 클릭
2. 실행 결과 확인:

```json
{
  "statusCode": 200,
  "body": "{\"message\":\"Hello, AWS Lambda!\",\"timestamp\":\"2024-01-15T10:30:00.000Z\"}"
}
```

**로그 확인**:
```
START RequestId: abc123 Version: $LATEST
받은 이벤트: {
  "name": "AWS Lambda"
}
END RequestId: abc123
REPORT RequestId: abc123
Duration: 45.67 ms
Billed Duration: 46 ms
Memory Size: 128 MB
Max Memory Used: 64 MB
```

---

## API Gateway 연동하기

Lambda 함수를 HTTP API로 노출하는 방법입니다.

### 1단계: API Gateway 생성

AWS 콘솔에서 API Gateway 서비스로 이동:

1. **API 생성** 클릭
2. **HTTP API** 선택
3. **통합 추가** → Lambda 함수 선택 (`MyFirstFunction`)
4. API 이름: `my-first-api`
5. **다음** 클릭
6. 경로 설정: `GET /hello`
7. **다음** → **생성**

### 2단계: API 테스트

생성된 API URL로 요청을 보내세요:

```bash
# API URL 복사 (예: https://abc123.execute-api.ap-northeast-2.amazonaws.com)
curl "https://abc123.execute-api.ap-northeast-2.amazonaws.com/hello?name=Developer"
```

**응답**:
```json
{
  "message": "Hello, Developer!",
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 3단계: Lambda 함수 업데이트

API Gateway 이벤트를 처리하도록 함수를 수정하세요:

```javascript
export const handler = async (event) => {
  console.log('API 요청:', JSON.stringify(event, null, 2));

  // 쿼리 파라미터 추출
  const name = event.queryStringParameters?.name || 'World';

  // 비즈니스 로직
  const greeting = `Hello, ${name}!`;

  // API Gateway 응답 형식
  return {
    statusCode: 200,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*' // CORS 허용
    },
    body: JSON.stringify({
      message: greeting,
      timestamp: new Date().toISOString(),
      requestId: event.requestContext.requestId
    })
  };
};
```

---

## 환경 변수 사용하기

설정값을 코드에서 분리하여 관리하세요.

### 환경 변수 설정

AWS 콘솔에서:
1. Lambda 함수 → **구성** 탭
2. **환경 변수** 섹션
3. **편집** 클릭
4. 환경 변수 추가:
   - Key: `GREETING_PREFIX`
   - Value: `안녕하세요`

### 코드에서 사용

```javascript
export const handler = async (event) => {
  // 환경 변수 읽기
  const prefix = process.env.GREETING_PREFIX || 'Hello';
  const apiKey = process.env.API_KEY; // 민감한 정보

  const name = event.name || 'World';
  const message = `${prefix}, ${name}!`;

  console.log('환경:', {
    prefix,
    hasApiKey: !!apiKey
  });

  return {
    statusCode: 200,
    body: JSON.stringify({ message })
  };
};
```

---

## 모니터링 및 로깅

### CloudWatch Logs

Lambda는 자동으로 로그를 CloudWatch에 전송합니다.

**로그 확인**:
1. Lambda 함수 → **모니터** 탭
2. **CloudWatch에서 로그 보기** 클릭

**효과적인 로깅**:
```javascript
export const handler = async (event) => {
  // 구조화된 로깅
  console.log('함수 시작', {
    timestamp: new Date().toISOString(),
    eventType: event.eventType,
    userId: event.userId
  });

  try {
    const result = await processData(event);

    console.log('처리 성공', {
      resultId: result.id,
      duration: result.processingTime
    });

    return { statusCode: 200, body: JSON.stringify(result) };
  } catch (error) {
    console.error('처리 실패', {
      error: error.message,
      stack: error.stack,
      event: JSON.stringify(event)
    });

    return { statusCode: 500, body: JSON.stringify({ error: error.message }) };
  }
};
```

### CloudWatch 메트릭

Lambda는 자동으로 다음 메트릭을 수집합니다:

- **Invocations**: 실행 횟수
- **Duration**: 실행 시간
- **Errors**: 오류 발생 횟수
- **Throttles**: 동시 실행 제한 초과 횟수
- **ConcurrentExecutions**: 동시 실행 수

**알람 설정 예시**:
```javascript
// CloudWatch 알람 - 오류율이 5%를 초과하면 알림
{
  "MetricName": "Errors",
  "Statistic": "Sum",
  "Period": 60,
  "EvaluationPeriods": 2,
  "Threshold": 5,
  "ComparisonOperator": "GreaterThanThreshold"
}
```

---

## 성능 최적화

### 1. 적절한 메모리 설정

메모리가 많을수록 CPU 성능도 높아집니다.

```javascript
// 메모리별 성능 비교
// 128MB: 실행 시간 1000ms, 비용 $0.0000002
// 512MB: 실행 시간 300ms,  비용 $0.0000003
// 1024MB: 실행 시간 200ms, 비용 $0.0000004

// 최적 메모리 찾기: AWS Lambda Power Tuning 도구 사용 권장
```

**권장 설정**:
- 간단한 API: 128-256MB
- 데이터 처리: 512-1024MB
- 이미지/비디오 처리: 1536-3008MB

### 2. 콜드 스타트 최소화

```javascript
// ❌ 나쁜 예: 함수 내부에서 초기화
export const handler = async (event) => {
  const { DynamoDBClient } = await import('@aws-sdk/client-dynamodb');
  const client = new DynamoDBClient(); // 매번 생성
  // ...
};

// ✅ 좋은 예: 전역 범위에서 초기화
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
const client = new DynamoDBClient(); // 재사용됨

export const handler = async (event) => {
  // 클라이언트 재사용
  // ...
};
```

### 3. 번들 크기 최적화

```bash
# 불필요한 의존성 제거
npm install --production

# esbuild로 번들링
npx esbuild index.js --bundle --platform=node --outfile=dist/index.js
```

### 4. 프로비저닝된 동시성

자주 호출되는 함수는 프로비저닝된 동시성을 설정하여 콜드 스타트를 제거할 수 있습니다.

```yaml
# serverless.yml
functions:
  api:
    handler: handler.handler
    provisionedConcurrency: 5  # 항상 5개 인스턴스 준비
```

**비용 고려**:
- 프로비저닝된 동시성은 유휴 시에도 요금이 발생
- 트래픽 패턴 분석 후 적용 권장

---

## 보안 모범 사례

### 1. 최소 권한 원칙

Lambda 실행 역할에 필요한 최소한의 권한만 부여하세요.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem"
      ],
      "Resource": "arn:aws:dynamodb:ap-northeast-2:123456789012:table/MyTable"
    },
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    }
  ]
}
```

### 2. 환경 변수 암호화

민감한 정보는 AWS Secrets Manager 또는 Systems Manager Parameter Store를 사용하세요.

```javascript
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';

const client = new SecretsManagerClient({ region: 'ap-northeast-2' });

// 시크릿 가져오기 (캐싱 권장)
let cachedSecret = null;

async function getSecret() {
  if (cachedSecret) return cachedSecret;

  const command = new GetSecretValueCommand({
    SecretId: 'my-api-key'
  });

  const response = await client.send(command);
  cachedSecret = JSON.parse(response.SecretString);

  return cachedSecret;
}

export const handler = async (event) => {
  const secrets = await getSecret();
  const apiKey = secrets.API_KEY;

  // apiKey 사용
  // ...
};
```

### 3. VPC 격리

민감한 리소스에 접근하는 Lambda는 VPC 내부에 배치하세요.

```yaml
# serverless.yml
functions:
  processData:
    handler: handler.handler
    vpc:
      securityGroupIds:
        - sg-12345678
      subnetIds:
        - subnet-12345678
        - subnet-87654321
```

**주의사항**:
- VPC Lambda는 NAT Gateway를 통해 인터넷 접근
- 콜드 스타트 시간 증가 가능 (ENI 생성)

### 4. 입력 검증

```javascript
export const handler = async (event) => {
  // 입력 검증
  if (!event.body) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: '요청 본문이 필요합니다.' })
    };
  }

  let data;
  try {
    data = JSON.parse(event.body);
  } catch (error) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: '잘못된 JSON 형식입니다.' })
    };
  }

  // 필수 필드 검증
  if (!data.email || !data.name) {
    return {
      statusCode: 400,
      body: JSON.stringify({
        error: 'email과 name은 필수 항목입니다.'
      })
    };
  }

  // 이메일 형식 검증
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(data.email)) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: '잘못된 이메일 형식입니다.' })
    };
  }

  // 비즈니스 로직 처리
  // ...
};
```

---

## 트러블슈팅

### 문제 1: 함수 타임아웃

**증상**:
```
Task timed out after 3.00 seconds
```

**원인**:
- 기본 타임아웃이 3초로 설정되어 있음
- 외부 API 호출이 느림
- 데이터베이스 쿼리가 오래 걸림

**해결 방법**:

1. **타임아웃 증가**:
```yaml
# serverless.yml
functions:
  myFunction:
    handler: handler.handler
    timeout: 30  # 30초로 증가 (최대 900초)
```

2. **비동기 처리**:
```javascript
// ❌ 동기 처리 (느림)
const results = [];
for (const item of items) {
  const result = await processItem(item);
  results.push(result);
}

// ✅ 병렬 처리 (빠름)
const results = await Promise.all(
  items.map(item => processItem(item))
);
```

### 문제 2: 메모리 부족

**증상**:
```
Runtime.OutOfMemory: The function exceeded its memory allocation
```

**해결 방법**:

1. **메모리 증가**:
```yaml
functions:
  myFunction:
    handler: handler.handler
    memorySize: 1024  # 1GB로 증가
```

2. **메모리 사용 최적화**:
```javascript
// ❌ 전체 파일을 메모리에 로드
const fileContent = await readFile('large-file.txt', 'utf-8');
processData(fileContent);

// ✅ 스트림 처리
const stream = createReadStream('large-file.txt');
await processStream(stream);
```

### 문제 3: 패키지 크기 초과

**증상**:
```
Unzipped size must be smaller than 262144000 bytes
```

**해결 방법**:

1. **불필요한 파일 제거**:
```bash
# .npmignore 파일 생성
test/
*.test.js
.git/
README.md
```

2. **레이어 사용**:
```yaml
# 공통 의존성을 레이어로 분리
layers:
  commonLibs:
    path: layer
    name: common-libs
    compatibleRuntimes:
      - nodejs20.x

functions:
  myFunction:
    handler: handler.handler
    layers:
      - {Ref: CommonLibsLambdaLayer}
```

### 문제 4: 권한 오류

**증상**:
```
AccessDeniedException: User is not authorized to perform: dynamodb:PutItem
```

**해결 방법**:

Lambda 실행 역할에 필요한 권한을 추가하세요:

```yaml
provider:
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:PutItem
            - dynamodb:GetItem
          Resource:
            - arn:aws:dynamodb:ap-northeast-2:*:table/MyTable
```

---

## 관련 개념

### 유사 개념

- **AWS Fargate**: 서버리스 컨테이너 실행 서비스
  - Lambda보다 긴 실행 시간 지원 (무제한)
  - 더 많은 메모리와 CPU 제공
  - 컨테이너 이미지 사용 가능

- **Google Cloud Functions**: Google의 서버리스 플랫폼
  - Lambda와 유사한 기능
  - Firebase와의 긴밀한 통합

- **Azure Functions**: Microsoft의 서버리스 플랫폼
  - Lambda와 유사한 기능
  - .NET 생태계 지원

### 대안

- **Amazon ECS/EKS**:
  - 언제: 복잡한 컨테이너 오케스트레이션 필요
  - 장점: 더 많은 제어, 긴 실행 시간
  - 단점: 관리 부담 증가

- **Amazon EC2**:
  - 언제: 지속적으로 높은 트래픽
  - 장점: 예측 가능한 비용, 완전한 제어
  - 단점: 서버 관리 필요

---

## 다음 단계

이제 AWS Lambda의 기본을 이해했으니, 다음 주제를 탐구해보세요:

### 심화 학습

- Lambda와 DynamoDB 통합 패턴
- 서버리스 프레임워크로 배포 자동화
- Lambda 레이어 활용하기
- Step Functions로 워크플로우 오케스트레이션

### 실전 프로젝트

- 서버리스 REST API 구축
- 이미지 처리 파이프라인 만들기
- 실시간 데이터 스트림 처리

### 모범 사례

- Lambda 비용 최적화 가이드
- 프로덕션 배포 체크리스트
- Lambda 보안 강화

---

## 참고 자료

### 공식 문서

- [AWS Lambda 개발자 가이드](https://docs.aws.amazon.com/lambda/)
- [Lambda 요금 정보](https://aws.amazon.com/lambda/pricing/)
- [Lambda 할당량 및 제한](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html)
