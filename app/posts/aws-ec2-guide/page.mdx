---
title: 'AWS EC2 이해하기'
date: '2026-01-26'
description: 'AWS EC2의 핵심 개념과 작동 원리를 이해하고, 가상화 기술과 탄력적 확장, 비용 최적화 전략을 배우는 완벽 가이드입니다.'
tags: ['AWS', 'EC2', '클라우드 컴퓨팅', '가이드', '인프라', 'IaaS', '온프레미스']
---

import { JsonLd } from '~/app/_components'

<JsonLd
  metadata={{
    title: 'AWS EC2 이해하기',
    description: 'AWS EC2의 핵심 개념과 작동 원리를 이해하고, 가상화 기술과 탄력적 확장, 비용 최적화 전략을 배우는 완범 가이드입니다.',
    date: '2026-01-26',
    slug: 'aws-ec2-guide',
    tags: ['AWS', 'EC2', '클라우드 컴퓨팅', '가이드', '인프라', 'IaaS', '온프레미스'],
  }}
/>

## 개요

AWS EC2(Elastic Compute Cloud)는 클라우드에서 가상 서버를 제공하는 서비스입니다. 물리적 서버를 구매하거나 관리할 필요 없이, 필요한 만큼의 컴퓨팅 파워를 빌려 사용하고 사용한 만큼만 비용을 지불합니다.

EC2를 사용하면 몇 분 안에 서버를 생성하고, 트래픽 증가에 따라 서버를 추가하거나 제거할 수 있습니다. 이는 마치 전기를 사용하는 것과 같습니다. 발전소를 직접 짓지 않고도 필요한 만큼 전기를 사용하고 요금만 내는 것처럼, EC2는 데이터센터를 직접 운영하지 않고도 서버를 사용할 수 있게 해줍니다.

---

## 배경

### 왜 필요한가?

전통적인 방식으로 웹 서비스를 운영하려면 다음과 같은 문제들이 있었습니다:

**초기 투자 비용 문제**
- 서버 하드웨어를 구매하는 데 수백만 원에서 수천만 원이 필요했습니다
- 트래픽이 적을 때도 고성능 서버를 미리 구매해야 했습니다
- 하드웨어가 고장나면 교체 비용이 추가로 발생했습니다

**확장성 문제**
- 사용자가 갑자기 증가하면 서버를 즉시 추가할 수 없었습니다
- 새 서버를 주문하고 설치하는 데 며칠에서 몇 주가 걸렸습니다
- 반대로 트래픽이 줄어들어도 이미 구매한 서버는 그대로 남아있었습니다

**운영 부담**
- 데이터센터 공간을 임대하거나 관리해야 했습니다
- 냉각, 전력, 네트워크 인프라를 직접 구축해야 했습니다
- 하드웨어 장애에 대비한 24시간 모니터링이 필요했습니다

### 등장 이전의 방식

#### 1. 온프레미스(On-Premises) 서버

회사가 직접 서버를 구매하고 관리하는 방식이었습니다:

```
[물리적 서버 구매] → [데이터센터 설치] → [네트워크 구성] → [서비스 배포]
     ↓                    ↓                   ↓                  ↓
  수주 소요           높은 초기비용        복잡한 설정        유지보수 부담
```

**예시**: 스타트업이 웹 서비스를 시작하려면
- 서버 구매: 500만 원
- 데이터센터 임대: 월 100만 원
- 네트워크 장비: 300만 원
- 전담 인력: 월 400만 원

초기 투자만 800만 원, 매월 500만 원 이상의 고정 비용이 발생했습니다.

#### 2. 호스팅 서비스

호스팅 업체의 서버 공간을 빌리는 방식:

```
[호스팅 신청] → [할당된 공간 사용] → [제한된 리소스 내에서 운영]
     ↓                ↓                        ↓
  비교적 저렴     설정이 제한적           확장 어려움
```

**장점**: 초기 비용이 적고 관리가 쉬웠습니다
**단점**: 다른 사용자와 서버를 공유하여 성능이 불안정하고, 급격한 트래픽 증가에 대응하기 어려웠습니다

---

## 동작 원리

### 핵심 메커니즘

EC2는 "가상화(Virtualization)" 기술을 기반으로 작동합니다. 하나의 강력한 물리적 서버를 여러 개의 독립적인 가상 서버로 나누어 사용합니다.

#### 1단계: 인스턴스 생성 요청

개발자가 AWS 콘솔이나 API를 통해 원하는 사양의 서버(인스턴스)를 요청합니다:

```javascript
// AWS SDK를 사용한 EC2 인스턴스 생성 예시
const AWS = require('aws-sdk');
const ec2 = new AWS.EC2({ region: 'ap-northeast-2' });

const params = {
  ImageId: 'ami-0c55b159cbfafe1f0',        // Ubuntu 서버 이미지
  InstanceType: 't2.micro',                 // 인스턴스 타입 (CPU, 메모리 사양)
  MinCount: 1,
  MaxCount: 1,
  KeyName: 'my-key-pair',                   // SSH 접속용 키
  SecurityGroupIds: ['sg-12345678']         // 방화벽 설정
};

// 인스턴스 생성
ec2.runInstances(params, (err, data) => {
  if (err) {
    console.error('인스턴스 생성 실패:', err);
  } else {
    console.log('인스턴스 생성 완료:', data.Instances[0].InstanceId);
    // 출력 예: i-1234567890abcdef0
  }
});
```

#### 2단계: 가상 서버 할당

AWS는 데이터센터의 물리적 서버 중에서 적절한 리소스를 찾아 가상 머신을 생성합니다:

```
[물리적 서버 - 96 CPU, 384GB RAM]
    ↓
    가상화 계층 (Hypervisor)
    ↓
┌─────────────┬─────────────┬─────────────┬─────────────┐
│  VM 1       │  VM 2       │  VM 3       │  VM 4       │
│  2 CPU      │  4 CPU      │  2 CPU      │  8 CPU      │
│  4GB RAM    │  8GB RAM    │  4GB RAM    │  16GB RAM   │
│  (당신의    │             │             │             │
│   인스턴스) │             │             │             │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

각 가상 머신은 독립적으로 작동하며, 다른 VM과 리소스를 간섭하지 않습니다.

#### 3단계: 운영 체제 부팅

선택한 AMI(Amazon Machine Image)를 기반으로 운영 체제가 부팅됩니다:

```
[AMI 선택]
    ↓
[Ubuntu 20.04 / Amazon Linux 2 / Windows Server]
    ↓
[운영 체제 부팅 - 약 30초~1분]
    ↓
[SSH/RDP 접속 가능 상태]
```

#### 4단계: 애플리케이션 배포

일반적인 리눅스 서버처럼 사용할 수 있습니다:

```bash
# SSH로 인스턴스 접속
ssh -i my-key-pair.pem ubuntu@ec2-13-125-123-45.ap-northeast-2.compute.amazonaws.com

# Node.js 애플리케이션 배포 예시
# 1. Node.js 설치
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# 2. 애플리케이션 코드 업로드 (git clone)
git clone https://github.com/yourusername/your-app.git
cd your-app

# 3. 의존성 설치
npm install

# 4. 애플리케이션 실행
npm start
# 서버가 3000번 포트에서 실행 중...
```

#### 5단계: 외부 접속 설정

보안 그룹(Security Group)을 통해 어떤 트래픽을 허용할지 설정합니다:

```
인터넷 사용자
    ↓
[보안 그룹 - 방화벽 규칙]
    ↓
포트 80 (HTTP) → 허용 ✓
포트 443 (HTTPS) → 허용 ✓
포트 22 (SSH) → 내 IP만 허용 ✓
포트 3306 (MySQL) → 차단 ✗
    ↓
[EC2 인스턴스]
```

### 시각적 예시: 전통적 방식 vs EC2

```
[전통적 방식]
주문 → 배송(2주) → 설치(3일) → 설정(2일) → 서비스 시작
━━━━━━━━━━━━━━━━━━━━━ 약 3주 소요 ━━━━━━━━━━━━━━━━━━━━

[EC2 방식]
클릭 → 생성(1분) → 설정(10분) → 서비스 시작
━━━━━━ 약 15분 소요 ━━━━━━
```

### 코드로 이해하기: Auto Scaling

EC2의 강력한 기능 중 하나는 트래픽에 따라 서버를 자동으로 증감하는 Auto Scaling입니다:

```javascript
// Auto Scaling 설정 예시
const autoScalingParams = {
  AutoScalingGroupName: 'my-app-asg',
  MinSize: 2,                    // 최소 2대 서버 유지
  MaxSize: 10,                   // 최대 10대까지 확장
  DesiredCapacity: 2,            // 평소에는 2대 운영

  // CPU 사용률이 70%를 넘으면 서버 추가
  TargetTrackingConfiguration: {
    PredefinedMetricType: 'ASGAverageCPUUtilization',
    TargetValue: 70.0
  }
};

// 실제 동작 예시
// 평소: 서버 2대 운영 (월 $20)
// 트래픽 급증: CPU 사용률 80% → 자동으로 서버 2대 추가 (총 4대)
// 트래픽 감소: CPU 사용률 50% → 자동으로 서버 2대 제거 (다시 2대)
```

---

## 주요 특징

### 특징 1: 탄력적 확장 (Elastic Scalability)

필요에 따라 컴퓨팅 리소스를 즉시 늘리거나 줄일 수 있습니다.

**수평 확장 (Scale Out/In)**
```
[평상시]
서버 1대 → 초당 100 요청 처리

[이벤트 기간]
서버 10대 → 초당 1,000 요청 처리

[이벤트 종료]
서버 2대 → 초당 200 요청 처리
```

**수직 확장 (Scale Up/Down)**
```javascript
// 인스턴스 타입 변경 예시
// 기존: t2.small (1 vCPU, 2GB RAM) → 월 $17
// 변경: t2.large (2 vCPU, 8GB RAM) → 월 $68

// 1. 인스턴스 중지
ec2.stopInstances({ InstanceIds: ['i-1234567890abcdef0'] });

// 2. 인스턴스 타입 변경
ec2.modifyInstanceAttribute({
  InstanceId: 'i-1234567890abcdef0',
  InstanceType: { Value: 't2.large' }
});

// 3. 인스턴스 시작
ec2.startInstances({ InstanceIds: ['i-1234567890abcdef0'] });
```

### 특징 2: 다양한 인스턴스 타입

용도에 맞는 최적화된 서버를 선택할 수 있습니다:

| 타입 | 용도 | 예시 | 월 비용 (서울 리전) |
|------|------|------|---------------------|
| **t2.micro** | 개발/테스트, 소규모 웹사이트 | 블로그, 간단한 API | $8.50 |
| **t3.medium** | 일반적인 웹 애플리케이션 | React/Node.js 앱 | $30 |
| **c5.large** | CPU 집약적 작업 | 데이터 처리, 머신러닝 학습 | $61 |
| **r5.large** | 메모리 집약적 작업 | 데이터베이스, 캐시 | $91 |
| **m5.large** | 균형잡힌 워크로드 | 프로덕션 웹 서버 | $70 |

**실제 선택 예시**:
```javascript
// 케이스 1: 개인 블로그
{
  InstanceType: 't2.micro',        // 1 vCPU, 1GB RAM
  // 이유: 트래픽이 적고 리소스 사용량이 낮음
}

// 케이스 2: 스타트업 웹 서비스
{
  InstanceType: 't3.medium',       // 2 vCPU, 4GB RAM
  // 이유: 버스트 성능으로 가성비 좋음
}

// 케이스 3: 대규모 데이터 처리
{
  InstanceType: 'c5.4xlarge',      // 16 vCPU, 32GB RAM
  // 이유: CPU 성능이 중요한 작업
}
```

### 특징 3: 종량제 요금 (Pay-as-you-go)

사용한 만큼만 비용을 지불합니다.

**요금 계산 예시**:
```
t2.medium 인스턴스 (시간당 $0.0464)

시나리오 1: 24시간 운영
$0.0464/시간 × 24시간 × 30일 = $33.41/월

시나리오 2: 업무시간만 운영 (월-금, 9시-18시)
$0.0464/시간 × 9시간 × 22일 = $9.19/월
  → 72% 비용 절감!

시나리오 3: Reserved Instance (1년 약정)
시간당 $0.0281 → $20.23/월
  → 39% 비용 절감!
```

**비용 최적화 전략**:
```javascript
// 1. 스케줄 기반 시작/중지
// 개발 서버를 업무 시간에만 운영
const schedule = {
  start: '0 9 * * MON-FRI',    // 평일 오전 9시 시작
  stop: '0 18 * * MON-FRI'     // 평일 오후 6시 중지
};

// 2. Spot Instance 활용 (최대 90% 할인)
const spotRequest = {
  InstanceType: 't3.medium',
  SpotPrice: '0.02',             // 최대 지불 가격
  // 일반 가격 $0.0464 → Spot 가격 ~$0.014
};

// 3. Savings Plans (1-3년 약정으로 72% 할인 가능)
```

### 특징 4: 글로벌 인프라

전 세계 33개 리전, 105개 가용 영역에서 서비스를 제공합니다.

```
[한국 사용자]                    [미국 사용자]
     ↓                                ↓
[서울 리전 EC2]              [버지니아 리전 EC2]
  응답 시간: 10ms              응답 시간: 10ms
     ↓                                ↓
동일한 애플리케이션, 빠른 로컬 응답
```

**멀티 리전 배포 예시**:
```javascript
// 글로벌 서비스를 위한 멀티 리전 구성
const regions = [
  {
    name: 'ap-northeast-2',    // 서울
    users: ['한국', '일본']
  },
  {
    name: 'us-east-1',         // 버지니아
    users: ['미국', '캐나다']
  },
  {
    name: 'eu-west-1',         // 아일랜드
    users: ['유럽']
  }
];

// 사용자는 가장 가까운 리전의 서버와 통신
// 결과: 전세계 어디서든 빠른 응답 속도
```

---

## 실제 사용 사례

### 사례 1: 스타트업의 MVP 개발

**상황**: 신규 서비스를 빠르게 출시하고 사용자 반응을 확인하고 싶음

```javascript
// 1단계: 최소 비용으로 시작
const initialSetup = {
  instance: 't2.micro',          // 프리 티어 (12개월 무료)
  storage: '8GB',                // 월 $0.80
  traffic: '15GB',               // 프리 티어 포함
  totalCost: '$0.80/월'          // 거의 무료!
};

// 2단계: 사용자 증가 시 확장
if (dailyUsers > 1000) {
  // 인스턴스 업그레이드
  upgradeInstance('t2.micro', 't3.small');
  // 비용: $15/월로 증가
}

// 3단계: 트래픽 급증 시 자동 확장
if (activeUsers > 10000) {
  // Auto Scaling으로 서버 자동 추가
  addInstances(3);  // 총 4대 운영
  // 비용: $60/월로 증가 (필요한 동안만)
}
```

**결과**:
- 초기 투자 비용 최소화
- 사용자 증가에 따라 점진적으로 확장
- 실패해도 큰 손실 없음

### 사례 2: 전자상거래 플랫폼의 특가 이벤트

**상황**: 블랙프라이데이 등 특별 이벤트 기간에만 트래픽이 10배 증가

```javascript
// 평소 (Auto Scaling 설정)
const normalPeriod = {
  instances: 3,                   // 서버 3대
  cpu: '30%',                     // CPU 사용률
  requests: '300 req/s',          // 초당 요청 수
  cost: '$150/월'
};

// 이벤트 기간 (Auto Scaling 자동 동작)
const eventPeriod = {
  instances: 30,                  // 서버 30대로 자동 증가
  cpu: '70%',                     // CPU 사용률 유지
  requests: '3000 req/s',         // 10배 증가한 트래픽 처리
  cost: '$1,500/월',              // 이벤트 기간(3일)만 비용 증가

  // 이벤트 종료 후
  autoScaleDown: true,            // 자동으로 3대로 축소
  totalEventCost: '$150'          // 3일간만 추가 비용
};
```

**전통적 방식과의 비교**:
```
[전통적 방식]
- 30대 서버 구매: 3,000만 원
- 연간 운영 비용: 6,000만 원
- 나머지 362일은 27대 서버가 놀고 있음 ❌

[EC2 방식]
- 초기 비용: 0원
- 평소 비용: 월 150달러
- 이벤트 비용: 3일간만 추가 150달러
- 필요할 때만 확장 ✓
```

### 사례 3: 머신러닝 모델 학습

**상황**: 대규모 데이터로 딥러닝 모델을 학습해야 하지만 고가의 GPU 서버를 구매하기 부담스러움

```javascript
// GPU 인스턴스를 필요할 때만 사용
const mlTraining = {
  instance: 'p3.2xlarge',         // V100 GPU 포함
  hourlyRate: '$3.06',            // 시간당 비용

  // 모델 학습 시나리오
  trainingTime: '8시간',
  totalCost: '$24.48',            // 1회 학습 비용

  // 학습 완료 후
  shutdown: true,                 // 즉시 종료하여 비용 절감

  // 월 10회 학습한다면
  monthlyCost: '$244.80'
};

// GPU 서버를 구매했다면?
const ownGPUServer = {
  initialCost: '15,000,000원',    // NVIDIA V100 GPU 서버
  monthlyCost: '500,000원',       // 전기, 냉각, 유지보수

  // 1년 총 비용
  yearlyTotal: '21,000,000원'
};

// EC2 사용 시 1년 비용
const ec2Yearly = '$244.80 × 12 = $2,937.60 (약 390만 원)';
// 약 1,800만 원 절감!
```

### 사례 4: 데브옵스 파이프라인

**상황**: CI/CD 파이프라인을 위한 빌드 서버가 필요하지만 항상 가동할 필요는 없음

```javascript
// GitHub Actions 트리거로 EC2 인스턴스 시작
const cicdPipeline = {
  // 1. 코드 푸시 감지
  trigger: 'git push',

  // 2. 빌드 서버 자동 시작
  startInstance: {
    type: 'c5.xlarge',            // 빌드에 최적화된 CPU
    startTime: '30초'
  },

  // 3. 빌드 및 테스트 실행
  build: {
    duration: '10분',
    tasks: ['npm install', 'npm test', 'npm run build']
  },

  // 4. 빌드 완료 후 자동 종료
  shutdown: 'automatic',

  // 비용 계산
  costPerBuild: '$0.17/시간 × 0.17시간 = $0.029',
  buildsPerDay: 20,
  monthlyCost: '$17.4'            // 매우 저렴!
};

// 24시간 가동했다면?
const alwaysOnCost = '$0.17 × 24 × 30 = $122.4';
// $105 절감!
```

---

## 장점과 한계

### 장점

#### ✅ 낮은 진입 장벽
- 초기 하드웨어 투자 없이 시작 가능
- 프리 티어로 12개월 무료 사용 가능
- 신용카드만 있으면 5분 안에 서버 생성

**실제 비용 예시**:
```
개인 프로젝트 시작
- 첫 12개월: 무료 (t2.micro)
- 이후: 월 $8.50

스타트업 웹 서비스
- 초기 (t3.small): 월 $15
- 성장기 (t3.medium + Auto Scaling): 월 $100~$500
- 대규모 (다수 인스턴스): 필요한 만큼

전통적 방식
- 초기: 최소 1,000만 원
- 매월: 최소 300만 원
```

#### ✅ 빠른 실험과 반복
- 새 서버를 1분 안에 생성
- 실패해도 즉시 삭제하고 재시작 가능
- 다양한 구성을 빠르게 테스트

```javascript
// A/B 테스트를 위한 두 가지 서버 구성 동시 실행
const experimentA = {
  instance: 't3.medium',
  app: 'node-v18',
  framework: 'express'
};

const experimentB = {
  instance: 't3.medium',
  app: 'node-v20',
  framework: 'fastify'
};

// 성능 측정 후 더 나은 것 선택
// 전체 과정 소요 시간: 1시간 이내
// 비용: $2 미만
```

#### ✅ 글로벌 확장 용이
- 전세계 데이터센터에 동일한 환경 구축
- 몇 번의 클릭으로 다른 리전에 서버 복제
- 사용자와 가까운 위치에서 서비스 제공

```javascript
// AMI(서버 스냅샷)를 다른 리전으로 복사
const globalDeployment = {
  sourceRegion: 'ap-northeast-2',      // 서울에서 테스트
  targetRegions: [
    'us-east-1',                       // 미국 동부
    'eu-west-1',                       // 유럽
    'ap-southeast-1'                   // 싱가포르
  ],

  // 동일한 설정으로 전세계에 배포
  deploymentTime: '30분',
  globalService: true
};
```

#### ✅ 통합된 AWS 에코시스템
- RDS(데이터베이스), S3(스토리지) 등과 쉽게 연동
- CloudWatch로 모니터링 자동화
- IAM으로 보안 관리 통합

```javascript
// EC2 + RDS + S3 통합 예시
const fullStackApp = {
  // 웹 서버
  ec2: {
    type: 't3.medium',
    app: 'Next.js'
  },

  // 데이터베이스
  rds: {
    engine: 'PostgreSQL',
    type: 'db.t3.small',
    autoBackup: true
  },

  // 파일 스토리지
  s3: {
    bucket: 'my-app-uploads',
    cdn: 'CloudFront 연동'
  },

  // 모니터링
  cloudWatch: {
    alerts: ['CPU > 80%', 'Disk > 90%'],
    dashboards: true
  }
};

// 모든 서비스가 같은 AWS 계정에서 통합 관리
```

### 한계

#### ⚠️ 복잡한 학습 곡선
- EC2 자체뿐만 아니라 VPC, 보안 그룹, IAM 등 관련 개념 학습 필요
- 최적화하지 않으면 예상보다 높은 비용 발생 가능
- 서버 관리 책임은 여전히 사용자에게 있음

**초보자가 겪는 흔한 실수**:
```javascript
// 실수 1: 보안 그룹 설정 오류
const dangerousSetup = {
  inboundRules: [
    { port: 22, source: '0.0.0.0/0' }    // 전세계에 SSH 개방 ❌
  ]
  // 올바른 설정: 내 IP만 허용
};

// 실수 2: 인스턴스를 계속 켜두기
const unnecessaryCost = {
  development: '개발 서버를 24시간 가동',
  weekend: '주말에도 실행',
  // 비용: 월 $50 → 업무시간만 사용하면 $15
};

// 실수 3: 모니터링 부족
const noMonitoring = {
  issue: 'CPU 100% 지속',
  reason: '무한 루프 버그',
  duration: '3일',
  cost: '불필요한 비용 $20 추가'
};
```

#### ⚠️ 서버 관리 부담
- OS 업데이트, 보안 패치는 직접 관리
- 애플리케이션 배포와 모니터링 필요
- 장애 대응 책임

```bash
# 해야 할 관리 작업들
# 1. 보안 업데이트
sudo apt-get update && sudo apt-get upgrade

# 2. 로그 모니터링
tail -f /var/log/application.log

# 3. 디스크 공간 관리
df -h  # 디스크 사용량 확인
du -sh /var/log/*  # 큰 로그 파일 찾기

# 4. 프로세스 관리
pm2 restart app  # 애플리케이션 재시작

# 5. 백업
aws s3 sync /data s3://my-backup-bucket/
```

#### ⚠️ 예측 불가능한 비용
- 트래픽 급증 시 비용도 급증
- 다양한 요금제(On-Demand, Reserved, Spot)의 최적 조합 찾기 어려움
- 네트워크 전송 비용 등 숨겨진 비용 존재

**비용 폭탄 예시**:
```javascript
// 시나리오: DDoS 공격을 받은 경우
const ddosAttack = {
  normalTraffic: '10GB/day',
  normalCost: '$0.90/day',

  attackTraffic: '1TB/day',           // 100배 증가
  attackCost: '$90/day',              // 비용도 100배
  duration: '3일',
  totalDamage: '$270',

  // 대책
  prevention: [
    'CloudFront (CDN) 사용',
    'AWS Shield 활성화',
    'Rate Limiting 설정',
    'Budget Alert 설정'
  ]
};
```

#### ⚠️ 벤더 종속성 (Vendor Lock-in)
- AWS 특화 기능을 많이 사용할수록 다른 클라우드로 이전이 어려움
- AWS API에 의존하는 코드가 많아짐
- 가격 인상 시 선택권 제한

```javascript
// AWS 특화 기능을 많이 사용한 경우
const tightlyCoupled = {
  compute: 'EC2',
  storage: 'S3',
  database: 'DynamoDB',              // AWS 전용
  queue: 'SQS',                      // AWS 전용
  notifications: 'SNS',              // AWS 전용
  lambda: 'Lambda',                  // AWS 전용

  // 다른 클라우드로 이전 시 대부분 재작성 필요 ❌
};

// 이식성을 고려한 설계
const loosleyCoupled = {
  compute: 'Docker 컨테이너',        // 어디서든 실행 가능
  storage: 'S3 호환 API 사용',       // MinIO 등으로 교체 가능
  database: 'PostgreSQL',            // 표준 SQL
  queue: 'RabbitMQ',                 // 오픈소스

  // 필요 시 다른 클라우드로 이전 가능 ✓
};
```

### 트레이드오프: 언제 EC2를 사용해야 할까?

#### EC2가 적합한 경우 ✓

```javascript
const useEC2When = {
  case1: {
    situation: '세밀한 인프라 제어가 필요',
    example: '특정 커널 모듈 설치, 시스템 레벨 튜닝',
    benefit: '완전한 root 권한'
  },

  case2: {
    situation: '비용 최적화가 중요',
    example: 'Spot Instance로 90% 할인',
    benefit: '다양한 요금제 옵션'
  },

  case3: {
    situation: '레거시 애플리케이션 마이그레이션',
    example: '기존 서버 환경과 동일하게 구성',
    benefit: '높은 호환성'
  },

  case4: {
    situation: '장기 실행 워크로드',
    example: '데이터베이스, 캐시 서버',
    benefit: 'Reserved Instance로 할인'
  }
};
```

#### EC2가 적합하지 않은 경우 ✗

```javascript
const avoidEC2When = {
  case1: {
    situation: '서버 관리가 부담스러움',
    alternative: 'Heroku, Vercel, Render',
    reason: '서버 관리를 서비스가 대신 처리'
  },

  case2: {
    situation: '짧은 시간의 간헐적 작업',
    alternative: 'AWS Lambda',
    reason: '실행 시간만 과금, 서버 유지 비용 없음'
  },

  case3: {
    situation: '컨테이너 오케스트레이션 필요',
    alternative: 'ECS, EKS',
    reason: 'EC2 관리 + 컨테이너 관리 이중 부담'
  },

  case4: {
    situation: '빠른 MVP 개발',
    alternative: 'PaaS (Heroku, Railway)',
    reason: 'git push로 즉시 배포 가능'
  }
};
```

---

## 관련 개념

### EC2 vs 다른 호스팅 솔루션 비교

#### 1. EC2 vs PaaS (Heroku, Vercel, Render)

**PaaS (Platform as a Service)란?**
- 서버 관리를 서비스가 대신하고, 개발자는 코드만 배포
- git push로 자동 배포, 자동 스케일링

**비교표**:

| 특징 | EC2 | PaaS (Heroku) |
|------|-----|---------------|
| **배포 방식** | SSH 접속, 수동 배포 | `git push heroku main` |
| **서버 관리** | 직접 관리 필요 (OS 업데이트 등) | 자동 관리 |
| **확장성** | 수동 또는 Auto Scaling 설정 | 자동 스케일링 |
| **학습 곡선** | 높음 (리눅스, 네트워킹 지식 필요) | 낮음 (코드만 작성) |
| **유연성** | 매우 높음 (모든 것 커스터마이징) | 제한적 (정해진 환경) |
| **비용 (소규모)** | $8.50/월 (t2.micro) | $7/월 (Eco dyno) |
| **비용 (중규모)** | $30/월 (t3.medium) | $25-50/월 |
| **비용 (대규모)** | 최적화 시 저렴 | 매우 비쌈 |

**코드로 비교**:

```javascript
// EC2 배포 과정
const ec2Deployment = {
  step1: 'SSH로 서버 접속',
  step2: 'git pull로 코드 업데이트',
  step3: 'npm install',
  step4: 'pm2 restart app',
  step5: '로그 확인 및 모니터링',

  time: '10-15분',
  expertise: '리눅스, DevOps 지식 필요'
};

// Heroku 배포 과정
const herokuDeployment = {
  step1: 'git push heroku main',

  time: '2분',
  expertise: 'git 사용법만 알면 됨'
};
```

**실제 선택 기준**:

```javascript
// 스타트업 초기: Heroku 선택
const startup = {
  team: '개발자 2명',
  priority: '빠른 기능 개발',
  serverKnowledge: '없음',
  decision: 'Heroku',
  reason: '서버 관리에 시간 낭비하지 않기'
};

// 성장기: EC2로 전환
const growthStage = {
  users: '10,000+',
  monthlyCost_heroku: '$500+',
  monthlyCost_ec2: '$200',
  decision: 'EC2로 마이그레이션',
  reason: '비용 절감 + 더 많은 제어권'
};
```

#### 2. EC2 vs 온프레미스 (On-Premises)

**온프레미스란?**
- 회사가 직접 물리적 서버를 구매하고 운영하는 방식

**비교표**:

| 특징 | EC2 | 온프레미스 |
|------|-----|-----------|
| **초기 비용** | $0 (종량제) | 수천만 원 (서버, 네트워크 장비) |
| **운영 비용** | 사용량 기반 | 고정 비용 (전기, 냉각, 인건비) |
| **확장 속도** | 몇 분 | 몇 주 ~ 몇 달 |
| **물리적 제어** | 없음 (가상화) | 완전한 제어 |
| **보안 책임** | 공유 (AWS와 분담) | 전적으로 회사 |
| **재해 복구** | 쉬움 (다른 리전으로 복제) | 어려움 (별도 백업 센터 필요) |
| **감가상각** | 없음 | 3-5년 |

**5년 총 소유 비용(TCO) 비교**:

```javascript
// 온프레미스 TCO (중소 규모 서비스)
const onPremisesTCO = {
  year0: {
    servers: '10대 × 500만 원 = 5,000만 원',
    network: '스위치, 라우터 = 1,000만 원',
    storage: 'SAN = 2,000만 원',
    installation: '500만 원',
    total: '8,500만 원'
  },

  yearlyOperating: {
    datacenter: '월 300만 원 × 12 = 3,600만 원',
    power: '월 150만 원 × 12 = 1,800만 원',
    staff: '시스템 관리자 2명 = 1억 원',
    maintenance: '500만 원',
    total: '1억 5,900만 원/년'
  },

  total5Years: '8억 4,500만 원'
};

// EC2 TCO (동일 성능)
const ec2TCO = {
  monthly: {
    instances: '10 × t3.large = $700',
    storage: 'EBS = $100',
    transfer: '$50',
    total: '$850/월 (약 110만 원)'
  },

  yearly: '110만 원 × 12 = 1,320만 원',
  total5Years: '6,600만 원',

  savings: '8억 4,500만 원 - 6,600만 원 = 7억 7,900만 원'
};

// 무려 92% 비용 절감!
```

**선택 기준**:

```javascript
const onPremisesIsBetter = {
  case1: '규제 요구사항 (금융권 등)',
  case2: '매우 안정적이고 예측 가능한 워크로드',
  case3: '초고성능 전용 하드웨어 필요 (HPC)',
  case4: '데이터 주권 문제 (특정 국가 내 데이터 보관)'
};

const ec2IsBetter = {
  case1: '변동하는 트래픽',
  case2: '빠른 확장 필요',
  case3: '초기 투자 최소화',
  case4: '글로벌 서비스',
  case5: '대부분의 경우' // 일반적으로 EC2가 유리
};
```

#### 3. EC2 vs AWS Lambda (서버리스)

**Lambda란?**
- 서버 없이 코드만 실행하는 서비스
- 요청이 들어올 때만 실행되고 과금됨

**비교표**:

| 특징 | EC2 | Lambda |
|------|-----|--------|
| **서버 관리** | 필요 | 불필요 (완전 관리형) |
| **과금 방식** | 시간 단위 | 실행 시간(100ms 단위) |
| **시작 시간** | 항상 실행 중 | 0.1~1초 (콜드 스타트) |
| **실행 시간 제한** | 없음 | 최대 15분 |
| **메모리** | 인스턴스 타입에 따라 | 128MB ~ 10GB |
| **상태 유지** | 가능 | 불가능 (무상태) |
| **최소 비용** | 시간당 $0.01~ | $0 (프리 티어: 월 100만 요청) |

**비용 비교 예시**:

```javascript
// 시나리오: API 서버 (하루 10,000 요청, 평균 100ms 실행)
const ec2Cost = {
  instance: 't3.micro',
  hourlyRate: '$0.0104',
  monthlyHours: 24 * 30,
  total: '$7.49/월',

  // 요청이 없어도 계속 과금
  idleTime: '대부분의 시간',
  efficiency: '낮음'
};

const lambdaCost = {
  requestsPerMonth: 10000 * 30,      // 300,000 요청
  avgDuration: 100,                   // 100ms
  memory: 512,                        // 512MB

  requestCost: '300,000 × $0.0000002 = $0.06',
  computeCost: '300,000 × 0.1초 × $0.0000166667 = $0.50',
  total: '$0.56/월',

  // 요청이 있을 때만 과금
  savings: '93% 절감!'
};

// 하지만 트래픽이 많으면?
const highTraffic = {
  requestsPerMonth: 10000000,         // 1천만 요청

  ec2Cost: '$7.49',                   // 동일
  lambdaCost: '$560',                 // 75배 증가!

  decision: 'EC2가 더 저렴'
};
```

**실제 선택 기준**:

```javascript
// Lambda가 적합한 경우
const lambdaUseCases = {
  case1: {
    name: '이벤트 기반 처리',
    example: '이미지 업로드 시 썸네일 생성',
    code: `
      // S3에 이미지 업로드 → Lambda 자동 실행
      exports.handler = async (event) => {
        const s3Object = event.Records[0].s3;
        // 썸네일 생성 로직
        return { statusCode: 200 };
      };
    `
  },

  case2: {
    name: '간헐적 작업',
    example: '매일 밤 리포트 생성',
    benefit: '하루 5분 실행, 나머지 시간 비용 0원'
  },

  case3: {
    name: '낮은 트래픽 API',
    example: '하루 1,000 요청 이하',
    benefit: '프리 티어 내에서 무료'
  }
};

// EC2가 적합한 경우
const ec2UseCases = {
  case1: {
    name: '항상 실행되는 서비스',
    example: '웹 서버, 데이터베이스',
    reason: 'Lambda는 15분 제한'
  },

  case2: {
    name: '높은 트래픽',
    example: '초당 100+ 요청',
    reason: 'EC2가 비용 효율적'
  },

  case3: {
    name: '복잡한 상태 관리',
    example: '웹소켓, 세션',
    reason: 'Lambda는 무상태'
  },

  case4: {
    name: '레거시 애플리케이션',
    example: '기존 서버 애플리케이션',
    reason: 'Lambda는 함수 단위 실행만 가능'
  }
};
```

#### 4. EC2 vs Elastic Beanstalk / ECS / EKS

**AWS의 다른 컴퓨팅 서비스들**:

```javascript
const awsComputeServices = {
  ec2: {
    level: 'IaaS (Infrastructure)',
    control: '최대',
    management: '수동',
    use: '완전한 제어가 필요할 때'
  },

  elasticBeanstalk: {
    level: 'PaaS (Platform)',
    control: '중간',
    management: '자동 (코드만 배포)',
    use: '빠른 배포, 간단한 앱',

    example: `
      # Elastic Beanstalk 배포
      $ eb init my-app
      $ eb create production
      $ eb deploy
      # 끝! EC2, 로드밸런서, Auto Scaling 자동 구성
    `
  },

  ecs: {
    level: 'Container Orchestration',
    control: '중간-높음',
    management: '컨테이너 자동 관리',
    use: 'Docker 컨테이너 실행',

    example: `
      # Docker 이미지만 있으면 자동 배포
      $ aws ecs update-service --service my-service
      # EC2 위에서 컨테이너 자동 관리
    `
  },

  eks: {
    level: 'Kubernetes',
    control: '높음',
    management: 'K8s 클러스터 관리',
    use: '복잡한 마이크로서비스',

    note: '가장 복잡하지만 가장 강력함'
  }
};
```

**추상화 수준 비교**:

```
[낮은 추상화 - 높은 제어]
EC2
 ↓
ECS (Docker 컨테이너)
 ↓
Elastic Beanstalk (PaaS)
 ↓
Lambda (Serverless)
[높은 추상화 - 낮은 제어]
```

**실제 프로젝트 선택 예시**:

```javascript
// 프로젝트 1: 개인 블로그
const personalBlog = {
  traffic: '하루 100명',
  choice: 'Elastic Beanstalk 또는 Vercel',
  reason: '서버 관리 하고 싶지 않음'
};

// 프로젝트 2: 스타트업 MVP
const startup = {
  traffic: '불확실',
  team: '개발자 3명',
  choice: 'Elastic Beanstalk',
  reason: '빠른 개발 + Auto Scaling'
};

// 프로젝트 3: 중규모 서비스
const mediumService = {
  traffic: '예측 가능',
  team: '개발자 10명 + DevOps',
  choice: 'EC2 + Auto Scaling',
  reason: '비용 최적화 + 충분한 제어'
};

// 프로젝트 4: 대규모 마이크로서비스
const enterprise = {
  services: '50+ 마이크로서비스',
  team: '개발자 100명',
  choice: 'EKS (Kubernetes)',
  reason: '복잡한 오케스트레이션 필요'
};
```

### 의사결정 플로우차트

```
시작
 ↓
서버 관리 가능?
 ↓              ↓
NO             YES
 ↓              ↓
PaaS/Lambda    장기 실행?
               ↓         ↓
              YES       NO
               ↓         ↓
              트래픽 많음?  Lambda
               ↓      ↓
              YES    NO
               ↓      ↓
              EC2   Elastic Beanstalk
               ↓
              컨테이너 사용?
               ↓         ↓
              YES       NO
               ↓         ↓
              ECS/EKS   일반 EC2
```

---

## 더 알아보기

### 심화 학습

**1. EC2 인스턴스 타입 완전 가이드**
- [인스턴스 타입별 성능 비교](https://aws.amazon.com/ec2/instance-types/)
- CPU, 메모리, 네트워크 성능 최적화
- 워크로드별 최적 타입 선택 전략

**2. 비용 최적화 전략**
- Reserved Instance vs Savings Plans 비교
- Spot Instance 활용법 (90% 할인)
- Cost Explorer를 활용한 비용 분석
- [AWS 비용 최적화 베스트 프랙티스](https://aws.amazon.com/pricing/cost-optimization/)

**3. Auto Scaling 심화**
- 예측 스케일링 (Predictive Scaling)
- 스케줄 기반 스케일링
- 타겟 트래킹 정책 설정
- [Auto Scaling 가이드](https://docs.aws.amazon.com/autoscaling/)

**4. 보안 강화**
- IAM 역할과 인스턴스 프로필
- VPC와 서브넷 설계
- 보안 그룹 베스트 프랙티스
- AWS Systems Manager를 통한 패치 관리

### 실습 프로젝트

**프로젝트 1: 간단한 웹 서버 배포 (초급)**
```
목표: EC2에 Node.js 애플리케이션 배포
- EC2 인스턴스 생성
- SSH 접속
- Node.js 설치 및 앱 실행
- 보안 그룹 설정으로 외부 접속 허용
예상 시간: 1시간
```

**프로젝트 2: Auto Scaling 구성 (중급)**
```
목표: 트래픽에 따라 자동 확장되는 웹 서비스
- Application Load Balancer 설정
- Launch Template 생성
- Auto Scaling Group 구성
- 부하 테스트로 스케일링 확인
예상 시간: 3시간
```

**프로젝트 3: 멀티 리전 배포 (고급)**
```
목표: 전세계 사용자를 위한 글로벌 서비스
- AMI 생성 및 다른 리전 복사
- Route 53으로 지연 시간 기반 라우팅
- CloudFront CDN 통합
- 리전간 데이터 동기화
예상 시간: 1일
```

### 참고 문서

**공식 문서**
- [AWS EC2 사용 설명서](https://docs.aws.amazon.com/ec2/)
- [EC2 요금 정보](https://aws.amazon.com/ec2/pricing/)
- [AWS 아키텍처 센터](https://aws.amazon.com/architecture/)

**커뮤니티 리소스**
- [AWS re:Post](https://repost.aws/) - AWS 공식 커뮤니티
- [r/aws](https://reddit.com/r/aws) - Reddit AWS 커뮤니티
- [AWS 한국 사용자 그룹](https://www.facebook.com/groups/awskrug/)

**도구 및 서비스**
- [AWS Calculator](https://calculator.aws/) - 비용 계산기
- [AWS CLI](https://aws.amazon.com/cli/) - 명령줄 도구
- [Terraform](https://www.terraform.io/) - 인프라 코드화(IaC)

### 다음 학습 경로

```
1. EC2 기초 마스터 (1-2주)
   ↓
2. VPC와 네트워킹 (1주)
   ↓
3. 로드 밸런싱과 Auto Scaling (1주)
   ↓
4. 모니터링과 로깅 (CloudWatch) (1주)
   ↓
5. 인프라 자동화 (Terraform/CloudFormation) (2주)
   ↓
6. 컨테이너와 오케스트레이션 (ECS/EKS) (4주)
```

**추천 학습 순서**:
1. **이론**: 이 문서 완독 ✓
2. **실습**: 프로젝트 1 완성 (웹 서버 배포)
3. **심화**: Auto Scaling 구성
4. **최적화**: 비용 분석 및 개선
5. **고급**: 멀티 리전 아키텍처

---

## 마치며

EC2는 강력하고 유연한 클라우드 컴퓨팅 서비스입니다. 초기에는 복잡해 보일 수 있지만, 기본 개념을 이해하고 나면 다양한 상황에 맞게 활용할 수 있습니다.

**핵심 요약**:
- EC2 = 클라우드의 가상 서버
- 사용한 만큼만 비용 지불
- 필요할 때 즉시 확장/축소 가능
- 완전한 제어권과 함께 관리 책임도 따라옴

**시작하기 전에 기억할 것**:
1. 작게 시작하세요 (t2.micro 프리 티어로)
2. 비용 알림을 설정하세요
3. 보안을 최우선으로 하세요
4. 실험을 두려워하지 마세요 (실패해도 삭제하면 됨)

이제 실제로 EC2 인스턴스를 생성해보면서 배운 내용을 실습해보세요!
